<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Valentine Adventure — Mobile + Xbox + Input Test Gate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
    body {
      margin: 0;
      background: #202030;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: sans-serif;
      touch-action: none; /* reduce accidental scrolling */
    }
    #game {
      border: 4px solid #fff;
      image-rendering: pixelated;
      background: #1b2033;
      touch-action: none; /* prevent scroll while touching canvas */
    }
    /* Mobile overlay controls */
    #controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      gap: 12px;
      pointer-events: auto;
      z-index: 10;
    }
    .ctrl-group { display: flex; gap: 12px; }
    button.ctrl {
      width: 64px; height: 64px;
      border-radius: 12px;
      border: 1px solid #ffffff88;
      background: #00000055;
      color: #fff;
      font-size: 20px;
      backdrop-filter: blur(4px);
      touch-action: none;
    }
    /* Hide controls on larger screens */
    @media (min-width: 900px) {
      #controls { display: none; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="controls">
    <div class="ctrl-group">
      <button class="ctrl" data-k="left">◀︎</button>
      <button class="ctrl" data-k="up">▲</button>
      <button class="ctrl" data-k="right">▶︎</button>
    </div>
    <div class="ctrl-group">
      <button class="ctrl" data-k="e">E</button>
    </div>
  </div>
  <script>
    //#region Core: Canvas, scaling, state
    const LOGICAL_WIDTH = 768;
    const LOGICAL_HEIGHT = 576;
    let SCALE = 1; // dynamic integer scale for crisp pixels

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function computeScale() {
      const vw = Math.max(320, window.innerWidth);
      const vh = Math.max(240, window.innerHeight);
      const maxScaleW = Math.floor(vw / LOGICAL_WIDTH);
      const maxScaleH = Math.floor(vh / LOGICAL_HEIGHT);
      const s = Math.max(1, Math.min(maxScaleW, maxScaleH));
      if (s !== SCALE) {
        SCALE = s;
        canvas.width = LOGICAL_WIDTH * SCALE;
        canvas.height = LOGICAL_HEIGHT * SCALE;
        ctx.imageSmoothingEnabled = false;
        ctx.setTransform(SCALE, 0, 0, SCALE, 0, 0);
      }
    }
    window.addEventListener('resize', computeScale);
    computeScale();

    const WIDTH = LOGICAL_WIDTH, HEIGHT = LOGICAL_HEIGHT;
    const TILE = 32, COLS = WIDTH / TILE, ROWS = HEIGHT / TILE;
    let state = "input_test"; // start at spoiler-free input test
    const keys = {};
    let gameStarted = false;
    //#endregion

    //#region Assets
    const ASSET_PATH = 'assets/';
    const SPRITES = {
      // Core & UI
      player_topdown: 'player_topdown.png',
      player_side: 'player_side.png',
      angry_bird: 'angry_bird.png',
      garfield_kitten: 'garfield_kitten.png',
      garfield_tiny: 'garfield_tiny.png',
      garfield_prince: 'garfield_prince.png',
      heart_icon: 'heart_icon.png',
      prompt_e: 'prompt_e.png',
      // Level 1 tiles
      tile_grass: 'tile_grass.png',
      tile_water: 'tile_water.png',
      tile_lilypad: 'tile_lilypad.png',
      tile_target: 'tile_target.png',
      flower_lily: 'flower_lily.png',
      flower_lilywater: 'flower_lilywater.png',
      house_small: 'house_small.png',
      // Jungle
      jungle_trunk: 'jungle_trunk.png',
      jungle_platform: 'jungle_platform.png',
      nest: 'nest.png',
      egg: 'egg.png',
      coconut: 'coconut.png',
      // House + feeding
      interior_floor: 'interior_floor.png',
      interior_wall: 'interior_wall.png',
      table: 'table.png',
      egg_whole: 'egg_whole.png',
      egg_cracked: 'egg_cracked.png',
      taco: 'taco.png',
      sushi_red: 'sushi_red.png',
      sushi_blue: 'sushi_blue.png',
      sushi_green: 'sushi_green.png',
      cake_bottom: 'cake_bottom.png',
      cake_middle: 'cake_middle.png',
      cake_top: 'cake_top.png',
      burger_legendary: 'burger_legendary.png',
      heart_effect: 'heart_effect.png',
      // Hub + mini-games
      hub_grass: 'hub_grass.png',
      house_exterior: 'house_exterior.png',
      stall_taco: 'stall_taco.png',
      stall_sushi: 'stall_sushi.png',
      stall_dessert: 'stall_dessert.png',
      cook_bar: 'cook_bar.png',
      cook_zone: 'cook_zone.png',
      cook_marker: 'cook_marker.png',
      fish_red: 'fish_red.png',
      fish_blue: 'fish_blue.png',
      fish_green: 'fish_green.png',
      plate_red: 'plate_red.png',
      plate_blue: 'plate_blue.png',
      plate_green: 'plate_green.png',
      cake_plate: 'cake_plate.png',
      // Dock + Undersea
      dock_planks: 'dock_planks.png',
      shoreline: 'shoreline.png',
      submarine: 'submarine.png',
      undersea_bg: 'undersea_bg.png',
      undersea_rock: 'undersea_rock.png',
      cave_entrance: 'cave_entrance.png',
      grill_shack: 'grill_shack.png',
      jellyfish: 'jellyfish.png',
      pickle: 'pickle.png',
      bubble: 'bubble.png',
      // Ship
      shipyard_ground: 'shipyard_ground.png',
      shed: 'shed.png',
      tree: 'tree.png',
      lab: 'lab.png',
      trash_can: 'trash_can.png',
      canopy_room: 'canopy_room.png',
      ship_part_fuselage: 'ship_part_fuselage.png',
      ship_part_canopy: 'ship_part_canopy.png',
      ship_part_wrapper: 'ship_part_wrapper.png',
      ship_part_jelly_fuel: 'ship_part_jelly_fuel.png',
      spaceship_blue: 'spaceship_blue.png',
      thruster_flame: 'thruster_flame.png',
      starfield: 'starfield.png',
      // Moon boss
      starfield_bg: 'starfield_bg.png',
      moon_disc: 'moon_disc.png',
      dragon_stage1: 'dragon_stage1.png',
      chest_gem: 'chest_gem.png',
      heart_bullet: 'heart_bullet.png',
      fireball: 'fireball.png',
      warning_circle: 'warning_circle.png',
      lunar_ground: 'lunar_ground.png',
      spire: 'spire.png',
      dragon_stage2: 'dragon_stage2.png',
      swipe_arc: 'swipe_arc.png',
      punch_effect: 'punch_effect.png',
      wish_star: 'wish_star.png',
      // Wish scene
      wish_room_bg: 'wish_room_bg.png',
      collar_charm: 'collar_charm.png',
      floating_heart: 'floating_heart.png'
    };
    const IMAGES = {};
    function loadImages(map) {
      const entries = Object.entries(map);
      return Promise.all(entries.map(([key, file]) => new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { IMAGES[key] = img; resolve(); };
        img.onerror = reject;
        img.src = ASSET_PATH + file;
      })));
    }
    function drawSprite(name, x, y, w, h) { const img = IMAGES[name]; if (img) ctx.drawImage(img, x, y, w, h); }
    //#endregion

    //#region Proportions, scaling, sprite helpers
    const PLAYER_SCALE_BY_STATE = {
      lily: 1.20,
      jungle: 0.70,
      house2: 1.25,
      hub2: 1.25,
      taco: 1.25,
      sushi: 1.25,
      dessert: 1.25,
      house3: 1.25,
      undersea: 0.75,
      ship_build: 1.25,
      ship_launch: 1.25,
      moon_boss: 1.25,
      wish_scene: 30.25
    };
    const scenePlayerScale = () => PLAYER_SCALE_BY_STATE[state] || 1.0;
    const BASE_PLAYER_H = 40;
    let CHARACTER_SCALE = 3.0;
    const WORLD_UNIT = () => Math.round(BASE_PLAYER_H * CHARACTER_SCALE);
    const LEVEL_WORLD_SCALE_BY_STATE = { undersea: 0.35 };
    const OBJECT_COLLISIONS_ENABLED = { undersea: false };
    const RELH = {
      player_side: 1.0, player_topdown: 1.0,
      angry_bird: 0.9, garfield_tiny: 0.65, garfield_kitten: 0.85, garfield_prince: 1.0,
      table: 0.65, cake_plate: 0.70, cake_bottom: 0.75, cake_middle: 0.65, cake_top: 0.55,
      sushi_red: 0.5, sushi_blue: 0.5, sushi_green: 0.5,
      plate_red: 0.55, plate_blue: 0.55, plate_green: 0.55,
      cook_bar: 0.6, cook_zone: 0.6, cook_marker: 0.9,
      submarine: 1.0, grill_shack: 2.2, cave_entrance: 1.6, undersea_rock: 0.9,
      jellyfish: 0.60, pickle: 0.50, egg_whole: 0.9
    };
    const ABS = {};
    function getSpriteSize(name) {
      const img = IMAGES[name];
      if (!img) return { w: 0, h: 0 };
      if (ABS[name]) return ABS[name];
      const unit = WORLD_UNIT();
      const isPlayer = (name === 'player_side' || name === 'player_topdown');
      const worldMul = LEVEL_WORLD_SCALE_BY_STATE[state] || 1.0;
      const targetH = Math.round((RELH[name] || 1.0) * unit * (isPlayer ? scenePlayerScale() : worldMul));
      const aspect = img.naturalWidth / img.naturalHeight || 1;
      return { w: Math.round(targetH * aspect), h: targetH };
    }
    function drawSpriteAuto(name, x, y, opts = {}) {
      const img = IMAGES[name]; if (!img) return;
      const { w, h } = getSpriteSize(name);
      const anchor = opts.anchor || 'bottom';
      let dx = x, dy = y;
      if (anchor === 'bottom') { dx = Math.round(x - w/2); dy = Math.round(y - h); }
      else if (anchor === 'center') { dx = Math.round(x - w/2); dy = Math.round(y - h/2); }
      ctx.drawImage(img, dx, dy, w, h);
    }
    //#endregion

    //#region Player hitbox + debug
    const PLAYER_METRICS = { widthScale: 0.6, heightScale: 0.9, insetBottom: 2 };
    function getPlayerBoxBottom(p) {
      const w = Math.round(p.w * PLAYER_METRICS.widthScale);
      const h = Math.round(p.h * PLAYER_METRICS.heightScale);
      const x = Math.round(p.x - w/2);
      const y = Math.round(p.y - h - PLAYER_METRICS.insetBottom);
      return { x, y, w, h };
    }
    function getPlayerBoxTopLeft(p) {
      const w = Math.round(p.w * PLAYER_METRICS.widthScale);
      const h = Math.round(p.h * PLAYER_METRICS.heightScale);
      const x = Math.round(p.x + (p.w - w)/2);
      const y = Math.round(p.y + (p.h - h) - PLAYER_METRICS.insetBottom);
      return { x, y, w, h };
    }
    let DEBUG_PLAYER = false;
    window.addEventListener('keydown', e => { if (e.key === 'F2') DEBUG_PLAYER = !DEBUG_PLAYER; });
    function debugDrawBox(b, feetX, feetY) {
      if (!DEBUG_PLAYER) return;
      ctx.strokeStyle = '#00ff99'; ctx.strokeRect(b.x, b.y, b.w, b.h);
      if (feetX !== undefined) {
        ctx.strokeStyle = '#ff00aa';
        ctx.beginPath(); ctx.moveTo(feetX-4, feetY); ctx.lineTo(feetX+4, feetY); ctx.moveTo(feetX, feetY-4); ctx.lineTo(feetX, feetY+4); ctx.stroke();
      }
    }
    //#endregion

    //#region Helpers, HUD, SFX, music, shake
    function rectsOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
    function drawHUDBar() { ctx.fillStyle = '#000000aa'; ctx.fillRect(0, 0, WIDTH, 40); }
    function drawBottomBar() { ctx.fillStyle = '#000000aa'; ctx.fillRect(0, HEIGHT - 40, WIDTH, 40); }
    function drawLowerHint(text) { ctx.fillStyle = '#000000aa'; ctx.fillRect(0, HEIGHT - 70, WIDTH, 30); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif'; ctx.fillText(text, 10, HEIGHT - 50); }
    function drawBottomPanelText(lines) { ctx.fillStyle = '#000000aa'; ctx.fillRect(0, HEIGHT - 80, WIDTH, 80); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif'; let y = HEIGHT - 56; for (const line of lines) { ctx.fillText(line, 10, y); y += 22; } }
    function drawDialogueBox(text) {
      const boxW = WIDTH - 40, boxH = 120, x = 20, y = HEIGHT - boxH - 20;
      ctx.fillStyle = '#000000dd'; ctx.fillRect(x, y, boxW, boxH);
      ctx.strokeStyle = '#ffffff'; ctx.strokeRect(x, y, boxW, boxH);
      ctx.fillStyle = '#ffffff'; ctx.font = '14px sans-serif';
      const lines = (text || '').split('\n');
      let ly = y + 24;
      for (const line of lines) {
        const words = line.split(' '); let cur = '';
        for (let i = 0; i < words.length; i++) {
          const test = cur + words[i] + ' ';
          if (ctx.measureText(test).width > boxW - 20) { ctx.fillText(cur, x + 10, ly); cur = words[i] + ' '; ly += 18; }
          else cur = test;
        }
        ctx.fillText(cur, x + 10, ly); ly += 18;
      }
    }
    function drawCenteredBanner(text) { ctx.fillStyle = '#000000aa'; ctx.fillRect(0, HEIGHT/2 - 30, WIDTH, 60); ctx.fillStyle = '#fff'; ctx.font = '16px sans-serif'; ctx.fillText(text, 110, HEIGHT/2); }
    function drawHPBar(x, y, w, hp, maxHp) { ctx.strokeStyle = '#fff'; ctx.strokeRect(x, y, w, 10); ctx.fillStyle = '#ff006e'; ctx.fillRect(x, y, w * (Math.max(0, hp)/maxHp), 10); }

    // Procedural SFX (oscillators)
    const AudioCtx = window.AudioContext ? new AudioContext() : null;
    function beep(freq=440, dur=0.08, vol=0.22, type='sine'){
      if(!AudioCtx) return;
      const o = AudioCtx.createOscillator(), g = AudioCtx.createGain();
      o.type = type; o.frequency.value = freq; o.connect(g); g.connect(AudioCtx.destination);
      const t = AudioCtx.currentTime; g.gain.value = vol; o.start(t); o.stop(t + dur);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    }
    const SFX = {
      shoot(){ beep(900,0.06,0.16,'square'); },
      hit(){ beep(220,0.08,0.28,'sawtooth'); },
      hurt(){ beep(120,0.12,0.3,'sine'); },
      punch(){ beep(300,0.06,0.25,'square'); },
      swipe(){ beep(520,0.07,0.22,'triangle'); },
      fire(){ beep(700,0.05,0.18,'triangle'); },
      pickup(){ beep(1000,0.06,0.2,'sine'); },
      success(){ beep(600,0.08,0.2,'sine'); setTimeout(()=>beep(800,0.08,0.2,'sine'),90); },
      jump(){ beep(260,0.05,0.2,'triangle'); }
    };
    window.addEventListener('keydown', () => { if (AudioCtx && AudioCtx.state === 'suspended') AudioCtx.resume(); }, { once:true });
    window.addEventListener('touchstart', () => { try { if (AudioCtx && AudioCtx.state === 'suspended') AudioCtx.resume(); } catch{} }, { once: true });

    // Background music manager (HTMLAudioElement + fades)
    const BGM = {
      audio: null,
      playWish(fadeMs=800){
        if (!this.audio){
          const a = new Audio(ASSET_PATH + 'wish_romance.mp3'); // include this file in assets/
          a.loop = true; a.volume = 0; this.audio = a;
        }
        const a = this.audio;
        a.currentTime = 0;
        a.play().catch(()=>{});
        const target = 0.6, steps = Math.max(1, Math.floor(fadeMs/50));
        const inc = target/steps;
        const id = setInterval(()=>{ a.volume = Math.min(target, a.volume + inc); if (a.volume >= target) clearInterval(id); }, 50);
      },
      stop(fadeMs=400){
        const a = this.audio; if (!a) return;
        const steps = Math.max(1, Math.floor(fadeMs/50));
        const dec = a.volume/steps;
        const id = setInterval(()=>{ a.volume = Math.max(0, a.volume - dec); if (a.volume <= 0){ clearInterval(id); a.pause(); } }, 50);
      }
    };
    window.addEventListener('keydown', () => {
      if (state==='wish_scene' && BGM.audio && BGM.audio.paused) { BGM.audio.play().catch(()=>{}); }
    });

    // Screen shake
    const SHK = { mag:0, t:0 };
    function shake(mag=4, frames=12){ SHK.mag = Math.max(SHK.mag, mag); SHK.t = Math.max(SHK.t, frames); }
    function applyShake(){ if(SHK.t>0){ SHK.t--; const dx=(Math.random()*2-1)*SHK.mag; const dy=(Math.random()*2-1)*SHK.mag; ctx.translate(dx,dy); SHK.mag*=0.85; } }
    //#endregion

    //#region Dev: jump via URL hash or console
    const LEVEL_INITS = {
      lily: initLily,
      jungle: initJungle,
      house2: initHouse2,
      hub2: initHub2,
      taco: initTaco,
      sushi: initSushi,
      dessert: initDessert,
      house3: initHouse3Dock,
      undersea: initUndersea,
      ship_build: initShipBuild,
      ship_launch: initShipLaunch,
      moon_boss: initMoonBoss,
      wish_scene: initWishScene
    };
    function jumpTo(level){
      if (!LEVEL_INITS[level]) return;
      const prev = state;
      state = level;
      LEVEL_INITS[level]();
      if (prev === 'wish_scene' && level !== 'wish_scene') BGM.stop(400);
      console.log('Jumped to:', level);
    }
    window.go = jumpTo;
    window.addEventListener('hashchange', () => {
      const h = location.hash.slice(1);
      if (LEVEL_INITS[h]) jumpTo(h);
    });
    //#endregion

    //#region Input Test (non-spoiler gate)
    const inputTest = {
      player: { x: WIDTH/2, y: HEIGHT/2, r: 12, speed: 3.2 },
      moved: false,
      gamepadSeen: false,
      touchSeen: false
    };
    function initInputTest(){
      inputTest.player.x = WIDTH/2;
      inputTest.player.y = HEIGHT/2;
      inputTest.moved = false;
      inputTest.gamepadSeen = false;
      inputTest.touchSeen = false;
    }
    function updateInputTest(){
      const p = inputTest.player;
      let dx = 0, dy = 0;
      if (keys['ArrowLeft'] || keys['a']) dx -= 1;
      if (keys['ArrowRight'] || keys['d']) dx += 1;
      if (keys['ArrowUp'] || keys['w']) dy -= 1;
      if (keys['ArrowDown'] || keys['s']) dy += 1;
      if (dx !== 0 || dy !== 0) inputTest.moved = true;
      const len = Math.hypot(dx, dy) || 1;
      p.x = Math.max(20, Math.min(WIDTH - 20, p.x + (dx/len) * inputTest.player.speed));
      p.y = Math.max(40, Math.min(HEIGHT - 40, p.y + (dy/len) * inputTest.player.speed));
    }
    function drawInputTest(){
      ctx.fillStyle = '#1b2033';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      drawHUDBar();
      ctx.fillStyle = '#fff';
      ctx.font = '14px sans-serif';
      ctx.fillText('Input Test: Move the dot with arrows/WASD or the controller.', 10, 20);
      ctx.fillText('Press E / Space / Enter, or A / Start on controller to begin.', 10, 36);
      const padConnected = !!(navigator.getGamepads && (navigator.getGamepads()[0] && navigator.getGamepads()[0].connected));
      const status = `Moved: ${inputTest.moved ? '✓' : ' '}  |  Gamepad: ${padConnected ? 'Detected' : 'None'}  |  Touch: ${inputTest.touchSeen ? '✓' : ' '}`;
      ctx.fillText(status, 10, 56);
      ctx.fillStyle = '#74c0fc';
      ctx.beginPath();
      ctx.arc(inputTest.player.x, inputTest.player.y, inputTest.player.r, 0, Math.PI*2);
      ctx.fill();
      drawBottomBar();
      ctx.fillStyle = '#fff';
      ctx.fillText('This screen has no spoilers. Start when you’re ready.', 10, HEIGHT - 18);
    }
    function inputTestInteract(key){
      if (key === ' ' || key === 'Enter' || (key && key.toLowerCase && key.toLowerCase() === 'e')) startFullGame();
    }
    function startFullGame(){
      if (gameStarted) return;
      gameStarted = true;
      state = 'loading';
      loadImages(SPRITES).then(()=>{
        initLily();
        state = 'lily';
      }).catch(err=>{
        console.error('Asset load error:', err);
        initLily();
        state = 'lily';
      });
    }
    //#endregion

    //#region Level: Lily
    const TILE_GRASS = 0, TILE_WATER = 1, TILE_LILYPAD = 2, TILE_LILY = 4, TILE_TARGET = 5, TILE_LILYWATER = 6;
    const LILY_OFFSET = { dx: 0, dy: 0 };
    const RAW_HEART_PADS = [
      '11,13','10,12','11,12','12,12',
      '9,11','10,11','11,11','12,11','13,11',
      '8,10','9,10','10,10','11,10','12,10','13,10','14,10',
      '8,9','9,9','10,9','11,9','12,9','13,9','14,9',
      '9,8','10,8','12,8','13,8'
    ];
    function heartWithOffset(dx, dy){
      return new Set(RAW_HEART_PADS.map(s=>{
        const [x,y]=s.split(',').map(Number);
        return `${x+dx},${y+dy}`;
      }));
    }
    const lily = {
      base: [], map: [],
      player: { x: 11, y: 13 },
      liliesCollected: 0, liliesPlaced: 0, totalTargets: 0,
      bird: { spawned: false, x: 12, y: 7, talking: false },
      house: { x: 10, y: 2, w: 4, h: 4 },
      edit: { enabled:false, selected:null, hover:null, dragging:false }
    };
    const LILY_SAVE_KEY = 'va_lily_layout_v1';
    function currentLilyPositions(){
      const out = [];
      for (let y=0;y<ROWS;y++){
        for (let x=0;x<COLS;x++){
          const t = lily.map[y][x];
          if (t === TILE_LILY || t === TILE_LILYWATER) out.push({x,y});
        }
      }
      return out;
    }
    function applyLilyLayout(list){
      for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){
        const t = lily.map[y][x];
        if (t === TILE_LILY || t === TILE_LILYWATER) lily.map[y][x] = TILE_GRASS;
      }
      for (const p of (list||[])){
        if (!lilyInsideBounds(p.x,p.y)) continue;
        const base = lily.base[p.y][p.x];
        lily.map[p.y][p.x] = (base === TILE_WATER || base === TILE_LILYPAD) ? TILE_LILYWATER : TILE_LILY;
      }
    }
    function saveLilyLayout(){ try { localStorage.setItem(LILY_SAVE_KEY, JSON.stringify(currentLilyPositions())); SFX.success(); } catch(e){} }
    function loadLilyLayout(){
      try {
        const raw = localStorage.getItem(LILY_SAVE_KEY);
        if (!raw) return null;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return null;
        return arr.filter(p => Number.isInteger(p.x) && Number.isInteger(p.y));
      } catch(e){ return null; }
    }
    function clearLilyLayout(){ localStorage.removeItem(LILY_SAVE_KEY); }
    function lilyMouseToTile(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) / SCALE;
      const my = (e.clientY - rect.top) / SCALE;
      return { x: Math.floor(mx / TILE), y: Math.floor(my / TILE) };
    }
    function initLily() {
      lily.base = []; lily.map = [];
      for (let y = 0; y < ROWS; y++) {
        lily.base[y] = []; lily.map[y] = [];
        for (let x = 0; x < COLS; x++) { lily.base[y][x] = TILE_GRASS; lily.map[y][x] = TILE_GRASS; }
      }
      const heartPads = heartWithOffset(LILY_OFFSET.dx, LILY_OFFSET.dy);
      const pts = Array.from(heartPads).map(s => s.split(',').map(n => parseInt(n,10)));
      const minX = Math.min(...pts.map(p=>p[0])), maxX = Math.max(...pts.map(p=>p[0]));
      const minY = Math.min(...pts.map(p=>p[1])), maxY = Math.max(...pts.map(p=>p[1]));
      for (let y = Math.max(0, minY); y <= Math.min(ROWS-1, maxY); y++) {
        for (let x = Math.max(0, minX); x <= Math.min(COLS-1, maxX); x++) {
          lily.base[y][x] = TILE_WATER;
        }
      }
      for (const [x, y] of pts) if (x>=0 && x<COLS && y>=0 && y<ROWS) lily.base[y][x] = TILE_LILYPAD;
      const has = (x,y) => heartPads.has(`${x},${y}`);
      const innerTargets = pts.filter(([x,y]) => has(x-1,y) && has(x+1,y) && has(x,y-1) && has(x,y+1));
      lily.totalTargets = innerTargets.length; lily.liliesPlaced = 0; lily.liliesCollected = 0;
      for (const [x,y] of innerTargets) if (x>=0 && x<COLS && y>=0 && y<ROWS) lily.map[y][x] = TILE_TARGET;
      const wild = [];
      for (let x = minX - 3; x <= maxX + 3 && wild.length < lily.totalTargets; x += 2) {
        const yTop = Math.max(0, minY - 3), yBottom = Math.min(ROWS-1, maxY + 3);
        if (lily.base[yTop]?.[x] === TILE_GRASS) wild.push([x, yTop]);
        if (wild.length < lily.totalTargets && lily.base[yBottom]?.[x] === TILE_GRASS) wild.push([x, yBottom]);
      }
      for (let y = minY - 2; y <= maxY + 2 && wild.length < lily.totalTargets; y += 2) {
        const xLeft = Math.max(0, minX - 3), xRight = Math.min(COLS-1, maxX + 3);
        if (lily.base[y]?.[xLeft] === TILE_GRASS) wild.push([xLeft, y]);
        if (wild.length < lily.totalTargets && lily.base[y]?.[xRight] === TILE_GRASS) wild.push([xRight, y]);
      }
      for (const [x,y] of wild) if (x>=0 && x<COLS && y>=0 && y<ROWS) lily.map[y][x] = TILE_LILY;
      const saved = loadLilyLayout();
      if (saved) applyLilyLayout(saved);
      lily.player.x = 11 + LILY_OFFSET.dx;
      lily.player.y = 13 + LILY_OFFSET.dy;
      lily.bird.spawned = false; lily.bird.talking = false;
      lily.edit.selected = null; lily.edit.hover = null; lily.edit.dragging = false;
      ensureLilyEditorBindings();
    }
    function lilyInsideBounds(nx, ny) { return nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS; }
    function lilyIsWalkable(tile) {
      return tile === TILE_GRASS || tile === TILE_LILYPAD || tile === TILE_LILY || tile === TILE_TARGET || tile === TILE_LILYWATER;
    }
    function lilyIsAdjacentToBird() {
      if (!lily.bird.spawned) return false;
      const dx = Math.abs(lily.player.x - lily.bird.x), dy = Math.abs(lily.player.y - lily.bird.y);
      return dx + dy === 1;
    }
    function lilyInteract() {
      if (lily.edit.enabled) return;
      const x = lily.player.x, y = lily.player.y, tile = lily.map[y][x];
      if (lily.bird.spawned && lilyIsAdjacentToBird()) {
        if (!lily.bird.talking) lily.bird.talking = true;
        else { lily.bird.talking = false; startJungleLevel(); }
        return;
      }
      if (lily.bird.talking) { lily.bird.talking = false; return; }
      if (tile === TILE_LILY || tile === TILE_LILYWATER) {
        lily.liliesCollected++; lily.map[y][x] = TILE_GRASS;
      }
      else if (tile === TILE_TARGET && lily.liliesCollected > 0) {
        lily.liliesCollected--; lily.liliesPlaced++;
        const base = lily.base[y][x];
        lily.map[y][x] = (base === TILE_WATER || base === TILE_LILYPAD) ? TILE_LILYWATER : TILE_LILY;
      }
      if (!lily.bird.spawned && lily.liliesPlaced === lily.totalTargets) {
        lily.bird.spawned = true;
        lily.bird.x = 12 + LILY_OFFSET.dx;
        lily.bird.y = 7 + LILY_OFFSET.dy;
      }
    }
    function canPickLilyAt(x,y){
      if (!lilyInsideBounds(x,y)) return false;
      const t = lily.map[y][x];
      return t === TILE_LILY || t === TILE_LILYWATER;
    }
    function canDropLilyAt(x,y){
      if (!lilyInsideBounds(x,y)) return false;
      const t = lily.map[y][x];
      return t !== TILE_LILY && t !== TILE_LILYWATER && t !== TILE_TARGET;
    }
    function moveSingleLily(fromX,fromY,toX,toY){
      if (!canPickLilyAt(fromX,fromY) || !canDropLilyAt(toX,toY)) return false;
      lily.map[fromY][fromX] = (lily.base[fromY][fromX] === TILE_WATER || lily.base[fromY][fromX] === TILE_LILYPAD) ? TILE_WATER : TILE_GRASS;
      const base = lily.base[toY][toX];
      lily.map[toY][toX] = (base === TILE_WATER || base === TILE_LILYPAD) ? TILE_LILYWATER : TILE_LILY;
      saveLilyLayout();
      return true;
    }
    let lilyEditorBound = false;
    function ensureLilyEditorBindings(){
      if (lilyEditorBound) return;
      canvas.addEventListener('mousedown', e=>{
        if(state!=='lily' || !lily.edit.enabled) return;
        const {x,y} = lilyMouseToTile(e);
        if (canPickLilyAt(x,y)){
          lily.edit.selected = {x,y};
          lily.edit.dragging = true;
        } else {
          lily.edit.selected = null;
          lily.edit.dragging = false;
        }
      });
      canvas.addEventListener('mousemove', e=>{
        if(state!=='lily' || !lily.edit.enabled) return;
        lily.edit.hover = lilyMouseToTile(e);
      });
      canvas.addEventListener('mouseup', e=>{
        if(state!=='lily' || !lily.edit.enabled) return;
        if (!lily.edit.dragging || !lily.edit.selected) { lily.edit.dragging = false; return; }
        const from = lily.edit.selected;
        const to = lilyMouseToTile(e);
        if (moveSingleLily(from.x, from.y, to.x, to.y)) SFX.success();
        lily.edit.selected = null;
        lily.edit.dragging = false;
      });
      canvas.addEventListener('contextmenu', e=>{
        if(state==='lily' && lily.edit.enabled){ e.preventDefault(); lily.edit.selected = null; lily.edit.dragging = false; }
      });
      window.addEventListener('keydown', e=>{
        if(state!=='lily') return;
        if(e.key==='F4'){ lily.edit.enabled = !lily.edit.enabled; lily.edit.selected=null; lily.edit.dragging=false; }
        if(!lily.edit.enabled) return;
        if(e.key==='Escape'){ lily.edit.selected=null; lily.edit.dragging=false; }
        if(e.key==='F5'){ saveLilyLayout(); }
        if(e.key==='F6'){ clearLilyLayout(); initLily(); }
      });
      window.exportLilies = () => JSON.stringify(currentLilyPositions());
      window.importLilies = (json) => { try { applyLilyLayout(JSON.parse(json)); saveLilyLayout(); } catch(e){ console.error('Bad JSON', e); } };
      window.clearLilyLayout = () => { clearLilyLayout(); initLily(); };
      window.moveLilies = (dx,dy)=>{ LILY_OFFSET.dx+=dx; LILY_OFFSET.dy+=dy; initLily(); };
      lilyEditorBound = true;
    }
    function updateLily() { /* grid-based */ }
    function drawLily() {
      for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
        const b = lily.base[y][x];
        if (b === TILE_GRASS) drawSprite('tile_grass', x*TILE, y*TILE, TILE, TILE);
        else if (b === TILE_WATER) drawSprite('tile_water', x*TILE, y*TILE, TILE, TILE);
        else if (b === TILE_LILYPAD) drawSprite('tile_lilypad', x*TILE, y*TILE, TILE, TILE);
      }
      for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
        const t = lily.map[y][x];
        if (t === TILE_TARGET) drawSprite('tile_target', x*TILE, y*TILE, TILE, TILE);
        else if (t === TILE_LILY) drawSprite('flower_lily', x*TILE, y*TILE, TILE, TILE);
        else if (t === TILE_LILYWATER) drawSprite('flower_lilywater', x*TILE, y*TILE, TILE, TILE);
      }
      const h = lily.house; drawSprite('house_small', h.x*TILE, h.y*TILE, h.w*TILE, h.h*TILE);
      drawSprite('player_topdown', lily.player.x*TILE, lily.player.y*TILE, TILE, TILE);
      if (lily.bird.spawned) drawSprite('angry_bird', lily.bird.x*TILE, lily.bird.y*TILE, TILE, TILE);
      drawHUDBar(); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif';
      ctx.fillText('Move: WASD / arrows | Interact: E / Space / Enter', 10, 18);
      ctx.fillText('Lilies in bag: ' + lily.liliesCollected + ' | Spots filled: ' + lily.liliesPlaced + '/' + lily.totalTargets, 10, 36);
      if (lily.edit.enabled){
        ctx.fillStyle = '#000000aa';
        ctx.fillRect(0, HEIGHT-70, WIDTH, 30);
        ctx.fillStyle = '#9cf';
        ctx.fillText('Lily Edit ON: drag any lily. F4 toggle | F5 save | F6 revert | Right-click cancel | Esc clear', 10, HEIGHT-50);
        const drawBox = (tx,ty,color)=>{
          ctx.strokeStyle = color; ctx.lineWidth = 2;
          ctx.strokeRect(tx*TILE+1, ty*TILE+1, TILE-2, TILE-2);
        };
        if (lily.edit.hover && lilyInsideBounds(lily.edit.hover.x, lily.edit.hover.y)) drawBox(lily.edit.hover.x, lily.edit.hover.y, '#66ddff');
        if (lily.edit.selected) drawBox(lily.edit.selected.x, lily.edit.selected.y, '#ffd54a');
      } else {
        if (lily.bird.spawned && lilyIsAdjacentToBird() && !lily.bird.talking) ctx.fillText('Press E / Space / Enter to talk to the bird', 10, HEIGHT - 10);
        if (lily.bird.talking) drawDialogueBox('Angry Bird: "Those monkeys stole my egg and hid it up in the jungle!"\nAngry Bird: "Will you climb up and get it back for me?"\n(Press E / Space / Enter to begin the climb)');
      }
    }
    //#endregion

    //#region Level: Jungle (no-cooldown jump)
    const jungle = {
      player: { x: 0, y: 0, vx: 0, vy: 0, w: 0, h: 0, onGround: false },
      platforms: [], coconuts: [],
      gravity: 0.25, moveSpeed: 3.8, jumpStrength: 16.5,
      hasEgg: false, eggCollected: false,
      nest: { x: 0, y: 0, w: TILE*2, h: TILE*2 }
    };
    function startJungleLevel() { state = "jungle"; initJungle(); }
    function initJungle() {
      const ps = getSpriteSize('player_side');
      jungle.platforms = [
        { x: WIDTH*0.05, y: HEIGHT*0.90, w: WIDTH*0.35, h: 22 },
        { x: WIDTH*0.45, y: HEIGHT*0.78, w: WIDTH*0.22, h: 20 },
        { x: WIDTH*0.25, y: HEIGHT*0.66, w: WIDTH*0.22, h: 20 },
        { x: WIDTH*0.55, y: HEIGHT*0.54, w: WIDTH*0.22, h: 20 },
        { x: WIDTH*0.35, y: HEIGHT*0.42, w: WIDTH*0.22, h: 20 },
        { x: WIDTH*0.70, y: HEIGHT*0.30, w: WIDTH*0.20, h: 20 }
      ];
      const ground = jungle.platforms[0];
      jungle.player = { x: ground.x + 10, y: ground.y - ps.h, vx:0, vy:0, w:ps.w, h:ps.h, onGround:true };
      jungle.coconuts = []; jungle.hasEgg = false; jungle.eggCollected = false;
      jungle.nest = { x: WIDTH*0.78, y: HEIGHT*0.20, w: TILE*2, h: TILE*2 };
      coconutTimer = 0;
    }
    let coconutTimer = 0;
    function updateJungle() {
      const p = jungle.player;
      p.vx = 0;
      if (keys['ArrowLeft'] || keys['a']) p.vx = -jungle.moveSpeed;
      if (keys['ArrowRight'] || keys['d']) p.vx =  jungle.moveSpeed;
      p.vy += jungle.gravity;
      p.x += p.vx;
      for (const plat of jungle.platforms) {
        const pb = getPlayerBoxTopLeft(p);
        if (rectsOverlap(pb, plat)) {
          if (p.vx > 0) p.x = plat.x - p.w + (p.w - pb.w)/2;
          if (p.vx < 0) p.x = plat.x + plat.w - (p.w - pb.w)/2;
          p.vx = 0;
        }
      }
      p.y += p.vy; p.onGround = false;
      for (const plat of jungle.platforms) {
        const pb = getPlayerBoxTopLeft(p);
        if (rectsOverlap(pb, plat)) {
          if (p.vy > 0) { p.y = plat.y - p.h + (p.h - pb.h); p.vy = 0; p.onGround = true; }
          else if (p.vy < 0) { p.y = plat.y + plat.h - (p.h - pb.h); p.vy = 0; }
        }
      }
      if (p.y + p.h > HEIGHT) {
        const ground = jungle.platforms[0];
        p.x = ground.x + 10; p.y = ground.y - p.h; p.vx = 0; p.vy = 0; p.onGround = true;
      }
      if (p.y < 0) p.y = 0;
      coconutTimer += 1;
      if (coconutTimer > 120) { coconutTimer = 0; jungle.coconuts.push({ x: Math.random()*(WIDTH-20)+10, y:-10, vx:0, vy:2, r:8 }); }
      for (const c of jungle.coconuts) c.y += c.vy;
      jungle.coconuts = jungle.coconuts.filter(c => c.y + c.r < HEIGHT);
      for (const c of jungle.coconuts) {
        const cb = { x: c.x - c.r, y: c.y - c.r, w: c.r*2, h: c.r*2 };
        const pb = getPlayerBoxTopLeft(p);
        if (rectsOverlap(pb, cb)) { const ground = jungle.platforms[0]; p.x = ground.x + 10; p.y = ground.y - p.h; p.vx = 0; p.vy = 0; p.onGround = true; break; }
      }
      const pb = getPlayerBoxTopLeft(p);
      if (rectsOverlap(pb, jungle.nest)) jungle.hasEgg = true;
    }
    function jungleInteract() { if (jungle.hasEgg && !jungle.eggCollected) { jungle.eggCollected = true; initHouse2(); state = "house2"; } }
    function drawJungle() {
      ctx.fillStyle = '#3C568C'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      for (let y = 0; y < HEIGHT; y += 64) drawSprite('jungle_trunk', 300, y, 40, 64);
      for (const plat of jungle.platforms) drawSprite('jungle_platform', plat.x, plat.y, plat.w, plat.h);
      drawSprite('nest', jungle.nest.x, jungle.nest.y, jungle.nest.w, jungle.nest.h);
      drawSprite('egg', jungle.nest.x + jungle.nest.w/2 - 10, jungle.nest.y - 18, 20, 18);
      drawSprite('player_side', jungle.player.x, jungle.player.y, jungle.player.w, jungle.player.h);
      debugDrawBox(getPlayerBoxTopLeft(jungle.player));
      for (const c of jungle.coconuts) drawSprite('coconut', c.x - c.r, c.y - c.r, c.r*2, c.r*2);
      drawHUDBar(); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif';
      ctx.fillText('Jungle: A/D or arrows to move, W/Up/Space to jump (no cooldown). F2 shows hitboxes.', 10, 18);
      if (jungle.hasEgg) { drawBottomBar(); ctx.fillStyle = '#fff'; ctx.fillText('You reached the egg! Press E / Space / Enter to bring it home.', 10, HEIGHT - 18); }
    }
    //#endregion

    //#region Level: House2, Hub, and Mini-games
    const FLOOR_TOP = HEIGHT - 220;
    const house2 = {
      player: { x: 0, y: 0, w: 0, h: 0 },
      bird:   { x: 0, y: 0, w: 0, h: 0 },
      egg:    { x: 0, y: 0, w: 0, h: 0 },
      garfield: { present: false, x: 0, y: 0, w: 0, h: 0 },
      garfieldStage: 'tiny',
      phase: "talk_bird", birdLine: 0, feedingStep: 0,
      tableRect: { x: 0, y: 0, w: 0, h: 0 }
    };
    function initHouse2() {
      const ps = getSpriteSize('player_side'), ab = getSpriteSize('angry_bird'), eg = getSpriteSize('egg_whole'), gt = getSpriteSize('garfield_tiny'), tbl = getSpriteSize('table');
      const tableX = WIDTH/2 - tbl.w/2, tableY = FLOOR_TOP + 14; house2.tableRect = { x: tableX, y: tableY, w: tbl.w, h: tbl.h };
      house2.player = { x: WIDTH*0.28, y: FLOOR_TOP + 160, w: ps.w, h: ps.h };
      house2.bird   = { x: WIDTH*0.68, y: FLOOR_TOP + 160, w: ab.w, h: ab.h };
      const tableTopY = tableY + 4, tableCenterX = tableX + tbl.w/2;
      house2.egg = { x: tableCenterX - eg.w/2, y: tableTopY, w: eg.w, h: eg.h };
      house2.garfield = { present: false, x: tableCenterX, y: tableTopY, w: gt.w, h: gt.h };
      house2.phase = "talk_bird"; house2.birdLine = 0; house2.garfieldStage = 'tiny'; house2.feedingStep = 0;
    }
    function moveHouse2Player(dx, dy) {
      house2.player.x = Math.max(60, Math.min(WIDTH - 60, house2.player.x + dx * TILE));
      house2.player.y = Math.max(FLOOR_TOP, Math.min(FLOOR_TOP + 180, house2.player.y + dy * TILE));
    }
    function drawHouse2() {
      drawSprite('interior_wall', 0, 0, WIDTH, FLOOR_TOP);
      drawSprite('interior_floor', 40, FLOOR_TOP, WIDTH - 80, HEIGHT - FLOOR_TOP);
      const t = house2.tableRect; drawSprite('table', t.x, t.y, t.w, t.h);
      if (!house2.garfield.present) {
        drawSprite('egg_whole', house2.egg.x, house2.egg.y - house2.egg.h, house2.egg.w, house2.egg.h);
      } else {
        const centerX = t.x + t.w/2, surfaceY = t.y + 4;
        drawSpriteAuto(house2.garfieldStage === 'tiny' ? 'garfield_tiny' : 'garfield_kitten', centerX, surfaceY, {anchor:'bottom'});
      }
      drawSpriteAuto('player_side', house2.player.x, house2.player.y, {anchor:'bottom'});
      debugDrawBox(getPlayerBoxBottom(house2.player), house2.player.x, house2.player.y);
      drawSpriteAuto('angry_bird', house2.bird.x, house2.bird.y, {anchor:'bottom'});
      drawHUDBar(); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif';
      ctx.fillText('House: Move with arrows/WASD. Interact: E / Space / Enter (F2 shows hitboxes)', 10, 22);
      if (house2.phase === "talk_bird") {
        const lines = ['Angry Bird: "You did it! You brought the egg back home!"', 'Angry Bird: "...Wait. Do you hear that? I think it\'s hatching!"'];
        drawDialogueBox(lines[house2.birdLine]);
      } else if (house2.phase === "check_egg") drawDialogueBox('Walk up to the table and press E to check the egg.');
      else if (house2.phase === "hatched") drawDialogueBox('Garfield: "Mrrrow... I\'m hungry..."');
      else if (house2.phase === "dialogue_choice") drawDialogueBox('Press 1: "Let\'s get you something yummy."   Press 2: "You\'re already demanding, huh?"');
      else if (house2.phase === "done") drawDialogueBox('Time to go outside and find Garfield some food.');
      else if (house2.phase === "feeding" || house2.phase === "feeding_end" || house2.phase === "post_burger") drawFeedingOverlay();
    }
    function house2Interact(key) {
      const p = house2.player;
      const distToTable = Math.abs(p.x - (house2.tableRect.x + house2.tableRect.w/2)) + Math.abs(p.y - (house2.tableRect.y + 4));
      if (house2.phase === "talk_bird") {
        if (key === ' ' || key === 'Enter' || key.toLowerCase() === 'e') { house2.birdLine += 1; if (house2.birdLine > 1) house2.phase = "check_egg"; }
      } else if (house2.phase === "check_egg") {
        if (distToTable < 140 && (key === ' ' || key === 'Enter' || key.toLowerCase() === 'e')) { house2.garfield.present = true; house2.garfieldStage = 'tiny'; house2.phase = "hatched"; }
      } else if (house2.phase === "hatched") {
        if (key === ' ' || key === 'Enter' || key.toLowerCase() === 'e') house2.phase = "dialogue_choice";
      } else if (house2.phase === "dialogue_choice") {
        if (key === ' ' || key === 'Enter') house2.phase = "done";
      } else if (house2.phase === "done") {
        if (key === ' ' || key === 'Enter' || key.toLowerCase() === 'e') { initHub2(); state = "hub2"; }
      } else if (house2.phase === "feeding") {
        if (key === ' ' || key === 'Enter' || key.toLowerCase() === 'e') { house2.feedingStep += 1; if (house2.feedingStep > 4) house2.phase = "feeding_end"; }
      } else if (house2.phase === "feeding_end") {
        if (key === ' ' || key === 'Enter' || key.toLowerCase() === 'e') { initHouse3Dock(); state = "house3"; }
      }
    }
    const hub2 = { player: { x: 0, y: 0, w: 0, h: 0 }, tacosDone: false, sushiDone: false, dessertDone: false };
    function initHub2() { const ps = getSpriteSize('player_side'); hub2.player = { x: WIDTH/2, y: HEIGHT - 120, w: ps.w, h: ps.h }; }
    function drawHub2() {
      drawSprite('hub_grass', 0, 0, WIDTH, HEIGHT);
      drawSprite('house_exterior', 300, HEIGHT - 140 - (80-50), 160, 160);
      drawSprite('stall_taco', 80, 80, 140, 84);
      drawSprite('stall_sushi', WIDTH - 220, 80, 140, 84);
      drawSprite('stall_dessert', WIDTH/2 - 60, 220, 140, 84);
      drawSpriteAuto('player_side', hub2.player.x, hub2.player.y, {anchor:'bottom'});
      debugDrawBox(getPlayerBoxBottom(hub2.player), hub2.player.x, hub2.player.y);
      drawHUDBar(); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif';
      ctx.fillText('Hub: Walk to a food area and press E to enter. (F2 shows hitboxes)', 10, 20);
      ctx.fillText('Tacos: ' + (hub2.tacosDone?'✓':' ') + ', Sushi: ' + (hub2.sushiDone?'✓':' ') + ', Dessert: ' + (hub2.dessertDone?'✓':' '), 10, 38);
      if (hub2.tacosDone && hub2.sushiDone && hub2.dessertDone) { drawBottomBar(); ctx.fillStyle = '#fff'; ctx.fillText('All foods collected! Walk back to the house and press E to feed Garfield.', 10, HEIGHT - 18); }
    }
    function moveHub2Player(dx, dy) { hub2.player.x = Math.max(20, Math.min(WIDTH - 40, hub2.player.x + dx*TILE)); hub2.player.y = Math.max(60, Math.min(HEIGHT - 40, hub2.player.y + dy*TILE)); }
    function hub2Interact(key) {
      if (!(key === ' ' || key === 'Enter' || key.toLowerCase() === 'e')) return;
      const p = hub2.player;
      if (!hub2.tacosDone && p.x > 60 && p.x < 240 && p.y > 60 && p.y < 200) { initTaco(); state = "taco"; return; }
      if (!hub2.sushiDone && p.x > WIDTH - 260 && p.x < WIDTH - 80 && p.y > 60 && p.y < 200) { initSushi(); state = "sushi"; return; }
      if (!hub2.dessertDone && p.x > WIDTH/2 - 80 && p.x < WIDTH/2 + 80 && p.y > 200 && p.y < 320) { initDessert(); state = "dessert"; return; }
      if (hub2.tacosDone && hub2.sushiDone && hub2.dessertDone && p.x > 300 && p.x < 380 && p.y > HEIGHT - 140 && p.y < HEIGHT - 80) { initFeedingScene(); state = "house2"; }
    }

    const tacoTown = { progress: 0, barX: 160, barY: HEIGHT/2 - 12, barW: WIDTH - 320, goodStart: 0, goodEnd: 0 };
    function initTaco() { tacoTown.progress = 0; }
    function drawTaco() {
      ctx.fillStyle = '#4a2c10'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      const barH = getSpriteSize('cook_bar').h, zoneH = getSpriteSize('cook_zone').h, marker = getSpriteSize('cook_marker');
      drawSprite('cook_bar', tacoTown.barX, tacoTown.barY, tacoTown.barW, barH);
      const gW = Math.max(80, Math.min(180, Math.floor(tacoTown.barW * 0.22)));
      const gX = tacoTown.barX + (tacoTown.barW - gW)/2;
      drawSprite('cook_zone', gX, tacoTown.barY, gW, zoneH);
      const t = Date.now()/400;
      const markerPos = tacoTown.barX + ((Math.sin(t)+1)/2)*tacoTown.barW;
      drawSprite('cook_marker', markerPos - marker.w/2, tacoTown.barY - (marker.h - barH)/2, marker.w, marker.h);
      drawBottomPanelText(['Taco Town: Press E when the marker is in the green zone to cook tacos.', 'Tacos cooked: ' + tacoTown.progress + ' / 3']);
      tacoTown.goodStart = gX; tacoTown.goodEnd = gX + gW;
    }
    function tacoInteract(key) {
      if (!(key === ' ' || key === 'Enter' || key.toLowerCase() === 'e')) return;
      const t = Date.now()/400, pos = tacoTown.barX + ((Math.sin(t)+1)/2)*tacoTown.barW;
      if (pos >= tacoTown.goodStart && pos <= tacoTown.goodEnd) tacoTown.progress += 1;
      if (tacoTown.progress >= 3) { hub2.tacosDone = true; state = "hub2"; }
    }

    const sushiStreet = { fishSlots: [{color:'red',placed:false},{color:'blue',placed:false},{color:'green',placed:false}], held: null, plates: { red:false, blue:false, green:false } };
    function initSushi() { sushiStreet.fishSlots.forEach(s=>s.placed=false); sushiStreet.held=null; sushiStreet.plates={red:false,blue:false,green:false}; }
    function drawSushi() {
      ctx.fillStyle='#0b1b33'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      ctx.fillStyle='#1f4f7b'; ctx.fillRect(0, HEIGHT-80, WIDTH, 80);
      ctx.fillStyle='#fff'; ctx.font='14px sans-serif';
      ctx.fillText('Sushi Street: Press 1/2/3 to pick fish, 7/8/9 to place on matching plate.', 10, HEIGHT-50);
      const baseX = WIDTH/2 - 140;
      sushiStreet.fishSlots.forEach((slot,i)=>{
        if(!slot.placed){ const key = slot.color==='red'?'sushi_red':slot.color==='blue'?'sushi_blue':'sushi_green';
          const s = getSpriteSize(key); drawSprite(key, baseX + i*120, HEIGHT/2 - 70, s.w, s.h); ctx.fillText(String(i+1), baseX+i*120+12, HEIGHT/2 - 30); }
      });
      ['red','blue','green'].forEach((color,i)=>{
        const px = baseX + i*120, plName = color==='red'?'plate_red':color==='blue'?'plate_blue':'plate_green';
        const pl = getSpriteSize(plName), py = HEIGHT/2 + 30;
        drawSprite(plName, px, py, pl.w, pl.h); ctx.fillText(String(7+i), px+24, py+36);
        if (sushiStreet.plates[color]) { const fish = color==='red'?'sushi_red':color==='blue'?'sushi_blue':'sushi_green'; const fs = getSpriteSize(fish); drawSprite(fish, px + (pl.w - fs.w)/2, py - fs.h + 2, fs.w, fs.h); }
      });
      if (sushiStreet.held) { const name = sushiStreet.held==='red'?'sushi_red':sushiStreet.held==='blue'?'sushi_blue':'sushi_green'; const hs = getSpriteSize(name); drawSprite(name, WIDTH-160, HEIGHT/2 - 10, hs.w, hs.h); ctx.fillText('Held', WIDTH-170, HEIGHT/2 - 24); }
    }
    function sushiInteract(key) {
      if (key==='1'||key==='2'||key==='3'){ const idx=parseInt(key,10)-1, slot=sushiStreet.fishSlots[idx]; if(!slot.placed && !sushiStreet.held){ sushiStreet.held=slot.color; slot.placed=true; } }
      else if (key==='7'||key==='8'||key==='9'){ const idx=parseInt(key,10)-7, color=['red','blue','green'][idx]; if(sushiStreet.held===color){ sushiStreet.plates[color]=true; sushiStreet.held=null; } }
      const anyUnplaced=sushiStreet.fishSlots.some(s=>!s.placed), allPlated=sushiStreet.plates.red&&sushiStreet.plates.blue&&sushiStreet.plates.green;
      if (!anyUnplaced && allPlated && !sushiStreet.held) { hub2.sushiDone = true; state = "hub2"; }
    }

    const CAKE_OVERLAP = 40;
    const dessertDunes = { correctOrder:['bottom','middle','top'], currentOrder:[], complete:false };
    function initDessert(){ dessertDunes.currentOrder=[]; dessertDunes.complete=false; }
    function drawDessert(){
      ctx.fillStyle='#e3c07a'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      ctx.fillStyle='#c78fff'; ctx.fillRect(0,HEIGHT-80,WIDTH,80);
      ctx.fillStyle='#fff'; ctx.font='14px sans-serif';
      const status = dessertDunes.complete?'Perfect! Press E to return.':'Dessert Dunes: Press 1 bottom, 2 middle, 3 top (in order).';
      ctx.fillText(status,10,HEIGHT-50);
      if(!dessertDunes.complete) ctx.fillText('Current: ' + dessertDunes.currentOrder.join(' > '), 10, HEIGHT-28);
      const plate = getSpriteSize('cake_plate'), plateX = WIDTH/2 - plate.w/2, plateY = HEIGHT/2 + 40;
      drawSprite('cake_plate', plateX, plateY, plate.w, plate.h);
      let curY = plateY - 2;
      for(const layer of dessertDunes.currentOrder.slice(0,3)){
        const name = layer==='bottom'?'cake_bottom':layer==='middle'?'cake_middle':'cake_top';
        const sz = getSpriteSize(name); curY -= (sz.h - CAKE_OVERLAP); drawSprite(name, WIDTH/2 - sz.w/2, curY, sz.w, sz.h);
      }
      if (dessertDunes.complete) { ctx.fillStyle = '#ffffff22'; ctx.fillRect(plateX, curY - 6, plate.w, 4); }
    }
    function dessertInteract(key){
      if (dessertDunes.complete){ if(key===' '||key==='Enter'||key.toLowerCase()==='e'){ hub2.dessertDone=true; state='hub2'; } return; }
      if(key==='1') dessertDunes.currentOrder.push('bottom'); else if(key==='2') dessertDunes.currentOrder.push('middle'); else if(key==='3') dessertDunes.currentOrder.push('top');
      if(dessertDunes.currentOrder.length===3){ if(dessertDunes.currentOrder.join(',')===dessertDunes.correctOrder.join(',')) dessertDunes.complete=true; else dessertDunes.currentOrder=[]; }
    }

    function initFeedingScene(){ house2.phase='feeding'; house2.garfield.present=true; house2.feedingStep=0; }
    function drawFeedingOverlay(){
      let text=''; if(house2.phase==='feeding'||house2.phase==='feeding_end'){
        if(house2.feedingStep===0) text='You bring Garfield tacos. He sniffs them, then turns his head away.';
        else if(house2.feedingStep===1) text='You try sushi next. He takes a bite, makes a "bleh" face.';
        else if(house2.feedingStep===2) text='You offer dessert. He watches the cupcakes, yawns, and flops over.';
        else if(house2.feedingStep===3) text='Garfield: "Mrrrow... still hungry. Something\'s missing..."';
        else text='You fed Garfield everything on land, but his craving lies deeper... Maybe under the sea. (Press E to continue.)';
      } else if(house2.phase==='post_burger'){
        const bsz=getSpriteSize('burger_legendary'); drawSprite('burger_legendary', house2.tableRect.x+house2.tableRect.w-bsz.w-8, house2.tableRect.y+6, bsz.w, bsz.h);
        drawSprite('heart_effect', house2.tableRect.x+house2.tableRect.w-bsz.w-24, house2.tableRect.y-10, 14,14);
        drawSprite('heart_effect', house2.tableRect.x+house2.tableRect.w-8, house2.tableRect.y-18, 14,14);
        if(house2.feedingStep===0) text='You offer the Legendary Burger. Garfield chomps it in one bite.';
        else if(house2.feedingStep===1) text='He begins to glow. The collar lights up, the empty star slot shining.';
        else if(house2.feedingStep===2) text='"This is the Wish Collar, made to hold a Wish Star."';
        else if(house2.feedingStep===3) text='"Only with the moon\'s Wish Star can its true power be unlocked."';
        else if(house2.feedingStep===4) text='Garfield: "Mrrrow... I feel different." He looks up at the moon.';
        else text='Outside, a blueprint of a blue spaceship flickers into view. "Next: Build a spaceship to reach the moon." (Press E)';
      }
      drawDialogueBox(text);
    }
    //#endregion

    //#region Level: House3 (Dock) and Undersea
    const house3 = { player:{x:0,y:0,w:0,h:0}, submarine:{x:0,y:0,w:0,h:0}, phase:'intro' };
    function initHouse3Dock(){ const ps=getSpriteSize('player_side'), sub=getSpriteSize('submarine'); house3.player={x:WIDTH*0.15,y:HEIGHT-160,w:ps.w,h:ps.h}; house3.submarine={x:WIDTH*0.68,y:HEIGHT-170,w:sub.w,h:sub.h}; house3.phase='intro'; }
    function moveHouse3Player(dx,dy){ house3.player.x=Math.max(20,Math.min(WIDTH-40,house3.player.x+dx*TILE)); house3.player.y=Math.max(260,Math.min(HEIGHT-40,house3.player.y+dy*TILE)); }
    function drawHouse3(){
      drawSprite('shoreline',0,HEIGHT-180,WIDTH,180); drawSprite('dock_planks',0,HEIGHT-200,WIDTH,20);
      drawSprite('submarine', house3.submarine.x, house3.submarine.y, house3.submarine.w, house3.submarine.h);
      if(house2.garfield.present){ const gName=house2.garfieldStage==='tiny'?'garfield_tiny':'garfield_kitten'; drawSpriteAuto(gName, house3.player.x-20, house3.player.y-10, {anchor:'bottom'}); }
      drawSpriteAuto('player_side', house3.player.x, house3.player.y, {anchor:'bottom'}); debugDrawBox(getPlayerBoxBottom(house3.player), house3.player.x, house3.player.y);
      drawHUDBar(); ctx.fillStyle='#fff'; ctx.font='14px sans-serif'; ctx.fillText('Walk to the submarine and press E to go under the sea.',10,22);
      if(house3.phase==='intro') drawDialogueBox('Garfield: "Mrrrow... I want something... legendary..." You remember a story about a burger under the sea.');
    }
    function house3Interact(key){
      if(!(key===' '||key==='Enter'||key.toLowerCase()==='e')) return;
      const pb=getPlayerBoxBottom(house3.player), sub=house3.submarine, sb={x:sub.x-20,y:sub.y-20,w:sub.w+40,h:sub.h+40};
      if(rectsOverlap(pb,sb)){ initUndersea(); state='undersea'; } else if(house3.phase==='intro') house3.phase='walk_to_dock';
    }
    function initHouse3PostBurger(){ house2.phase='post_burger'; house2.feedingStep=0; house3.phase='post_burger'; }
    function drawHouse3PostBurger(){
      house2.garfieldStage='kitten'; drawSprite('interior_wall',0,0,WIDTH,FLOOR_TOP); drawSprite('interior_floor',40,FLOOR_TOP,WIDTH-80,HEIGHT-FLOOR_TOP);
      drawSprite('table', house2.tableRect.x, house2.tableRect.y, house2.tableRect.w, house2.tableRect.h);
      drawSpriteAuto('garfield_kitten', house2.tableRect.x+house2.tableRect.w/2, house2.tableRect.y+4, {anchor:'bottom'});
      drawSpriteAuto('player_side', WIDTH/2, FLOOR_TOP+160, {anchor:'bottom'}); drawFeedingOverlay();
    }

    const undersea = {
      player:{x:0,y:0,vx:0,vy:0,w:0,h:0},
      gravity:0.04, swimForce:-0.15, moveSpeed:1.2,
      jellyfish:[], pickles:[],
      seabedY: HEIGHT - 96,
      grillArea:{x:0,y:0,w:0,h:0},
      caveEntrance:{x:0,y:0,w:0,h:0},
      exitSub:{x:0,y:0,w:0,h:0},
      obstacles: [],
      jellyCollected:0, picklesCollected:0, bunsPattyCollected:false, burgerMade:false,
      bayLeft:0, bayRight:0
    };
    function initUndersea() {
      const ps = getSpriteSize('player_side');
      undersea.player = { x: Math.round(WIDTH * 0.30), y: undersea.seabedY - ps.h - 12, vx:0, vy:0, w:ps.w, h:ps.h };
      const shackSz = getSpriteSize('grill_shack');
      const caveSz  = getSpriteSize('cave_entrance');
      const rockSz  = getSpriteSize('undersea_rock');
      const subSz   = getSpriteSize('submarine');
      const margin = 28, seabedOffset = -8;
      const subX = margin, subY = undersea.seabedY - subSz.h + seabedOffset;
      undersea.exitSub = { x: subX, y: subY, w: subSz.w, h: subSz.h };
      const caveX = WIDTH - caveSz.w - margin, caveY = undersea.seabedY - caveSz.h + seabedOffset;
      undersea.caveEntrance = { x: caveX, y: caveY, w: caveSz.w, h: caveSz.h };
      let shackX = Math.round(WIDTH * 0.60) - Math.round(shackSz.w / 2);
      shackX = Math.max(subX + subSz.w + 80, Math.min(caveX - shackSz.w - 80, shackX));
      const shackY = undersea.seabedY - shackSz.h + seabedOffset;
      undersea.grillArea = { x: shackX, y: shackY+40, w: shackSz.w, h: shackSz.h };
      undersea.bayLeft  = undersea.exitSub.x + undersea.exitSub.w + 40;
      undersea.bayRight = undersea.grillArea.x - 40;
      const rock1 = { x: undersea.bayLeft + 20, y: undersea.seabedY - rockSz.h + seabedOffset, w: rockSz.w, h: rockSz.h };
      const rock2X = Math.min(undersea.bayRight - rockSz.w - 20, undersea.bayLeft + 120);
      const rock2 = { x: rock2X, y: undersea.seabedY - rockSz.h + seabedOffset - 6, w: rockSz.w, h: rockSz.h };
      undersea.obstacles = [rock1, rock2];
      undersea.jellyfish = [];
      const jfCount = 6;
      const span = Math.max(80, undersea.bayRight - undersea.bayLeft - 60);
      const baseBottom = undersea.seabedY - 80;
      for (let i = 0; i < jfCount; i++) {
        const ox = undersea.bayLeft + 30 + i * (span / (jfCount - 1));
        const oy = baseBottom - (i % 2) * 40;
        undersea.jellyfish.push({
          caught: false,
          ox, oy,
          x: ox, y: oy,
          ampX: 28 + Math.random() * 20,
          ampY: 14 + Math.random() * 16,
          freqX: 0.22 + Math.random() * 0.18,
          freqY: 0.28 + Math.random() * 0.22,
          phase: Math.random() * Math.PI * 2,
          drift: (Math.random() * 2 - 1) * 0.25
        });
      }
      const pk = getSpriteSize('pickle');
      undersea.pickles = [
        { x: undersea.caveEntrance.x + 14,                                   y: undersea.caveEntrance.y - 26, w: pk.w, h: pk.h, taken:false },
        { x: undersea.caveEntrance.x + undersea.caveEntrance.w/2 - pk.w/2,   y: undersea.caveEntrance.y - 38, w: pk.w, h: pk.h, taken:false },
        { x: undersea.caveEntrance.x + undersea.caveEntrance.w - pk.w - 14,  y: undersea.caveEntrance.y - 26, w: pk.w, h: pk.h, taken:false }
      ];
      undersea.jellyCollected = 0;
      undersea.picklesCollected = 0;
      undersea.bunsPattyCollected = false;
      undersea.burgerMade = false;
    }
    function resolveAgainstObstacles(p) {
      let safety = 3;
      while (safety-- > 0) {
        const b = getPlayerBoxBottom(p);
        let hit = null, pushX = 0, pushY = 0, minPen = Infinity;
        for (const o of undersea.obstacles) {
          if (!rectsOverlap(b, o)) continue;
          const dxLeft  = (o.x + o.w) - b.x;
          const dxRight = (b.x + b.w) - o.x;
          const dyUp    = (b.y + b.h) - o.y;
          const dyDown  = (o.y + o.h) - b.y;
          const penX = Math.min(dxLeft, dxRight);
          const penY = Math.min(dyUp, dyDown);
          if (penX < penY && penX < minPen) { minPen = penX; hit = o; pushX = (dxLeft < dxRight) ? dxLeft : -dxRight; pushY = 0; }
          else if (penY <= penX && penY < minPen) { minPen = penY; hit = o; pushX = 0; pushY = (dyUp < dyDown) ? -dyUp : dyDown; }
        }
        if (!hit) break;
        const bNow = getPlayerBoxBottom(p);
        p.x = Math.round(bNow.x + pushX + bNow.w / 2);
        p.y = Math.round(bNow.y + pushY + bNow.h + PLAYER_METRICS.insetBottom);
        if (pushX) p.vx = 0;
        if (pushY) p.vy = 0;
      }
    }
    function resolveAgainstObstaclesIfEnabled(p) {
      if (OBJECT_COLLISIONS_ENABLED[state]) resolveAgainstObstacles(p);
    }
    function updateUndersea() {
      const p = undersea.player;
      p.vx = 0;
      if (keys['ArrowLeft'] || keys['a'])  p.vx = -undersea.moveSpeed;
      if (keys['ArrowRight'] || keys['d']) p.vx =  undersea.moveSpeed;
      if (keys['ArrowUp'] || keys['w'] || keys[' ']) p.vy += undersea.swimForce;
      p.vy += undersea.gravity;
      p.x += p.vx; p.y += p.vy;
      const topY = 60;
      if (p.x - p.w/2 < 0) p.x = p.w/2;
      if (p.x + p.w/2 > WIDTH) p.x = WIDTH - p.w/2;
      if (p.y - p.h < topY) { p.y = topY + p.h; p.vy = 0; }
      if (p.y > undersea.seabedY) { p.y = undersea.seabedY; p.vy = 0; }
      resolveAgainstObstaclesIfEnabled(p);
      const t = performance.now() * 0.001;
      for (const j of undersea.jellyfish) {
        if (j.caught) continue;
        const left = undersea.bayLeft + 16, right = undersea.bayRight - 16;
        j.ox += j.drift;
        if (j.ox < left || j.ox > right) { j.drift *= -1; j.ox = Math.max(left, Math.min(right, j.ox)); }
        j.x = j.ox + j.ampX * Math.sin(2 * Math.PI * j.freqX * t + j.phase);
        j.y = j.oy + j.ampY * Math.sin(2 * Math.PI * j.freqY * t + j.phase + Math.PI / 2);
      }
      for (const pk of undersea.pickles) {
        if (!pk.taken) {
          const pb = getPlayerBoxBottom(p);
          if (rectsOverlap(pb, pk)) { pk.taken = true; undersea.picklesCollected += 1; SFX.pickup(); }
        }
      }
    }
    function drawUndersea() {
      drawSprite('undersea_bg', 0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#245c69';
      ctx.fillRect(0, undersea.seabedY, WIDTH, HEIGHT - undersea.seabedY);
      for (const o of undersea.obstacles) drawSprite('undersea_rock', o.x, o.y, o.w, o.h);
      drawSprite('grill_shack',    undersea.grillArea.x,    undersea.grillArea.y,    undersea.grillArea.w,    undersea.grillArea.h);
      drawSprite('cave_entrance',  undersea.caveEntrance.x, undersea.caveEntrance.y, undersea.caveEntrance.w, undersea.caveEntrance.h);
      drawSprite('submarine',      undersea.exitSub.x,      undersea.exitSub.y,      undersea.exitSub.w,      undersea.exitSub.h);
      for (const j of undersea.jellyfish) {
        if (j.caught) continue;
        const s = getSpriteSize('jellyfish');
        drawSprite('jellyfish', Math.round(j.x - s.w/2), Math.round(j.y - s.h/2), s.w, s.h);
      }
      for (const pk of undersea.pickles) if (!pk.taken) drawSprite('pickle', pk.x, pk.y, pk.w, pk.h);
      drawSpriteAuto('player_side', undersea.player.x, undersea.player.y, {anchor:'bottom'});
      debugDrawBox(getPlayerBoxBottom(undersea.player), undersea.player.x, undersea.player.y);
      drawHUDBar(); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif';
      ctx.fillText('Undersea: A/D to swim, W/Up/Space to swim up. E to interact / net. (F2 shows hitboxes)', 10, 20);
      ctx.fillText('Jelly: ' + undersea.jellyCollected + '/5  | Pickles: ' + undersea.picklesCollected + '/3  | Burger parts: ' + (undersea.bunsPattyCollected ? 'OK' : 'Missing'), 10, 38);
      const pb = getPlayerBoxBottom(undersea.player);
      if (rectsOverlap(pb, undersea.grillArea)) drawLowerHint('Press E to try assembling the Legendary Burger.');
      drawBottomBar(); ctx.fillStyle = '#fff';
      if (!undersea.burgerMade) ctx.fillText('Catch jellyfish in the bay, grab pickles above the cave, then return to the Grill Shack.', 10, HEIGHT - 18);
      else ctx.fillText('Legendary Burger made! Swim to the left submarine and press E to return home.', 10, HEIGHT - 18);
      if (undersea.burgerMade) {
        const b = getSpriteSize('burger_legendary');
        drawSprite('burger_legendary', undersea.grillArea.x + undersea.grillArea.w/2 - b.w/2 - 80, undersea.grillArea.y + 80, b.w, b.h);
      }
    }
    function underseaInteract(key) {
      const isInteract = key === ' ' || key === 'Enter' || (key && key.toLowerCase && key.toLowerCase() === 'e');
      if (!isInteract) return;
      const p = undersea.player;
      const pb = getPlayerBoxBottom(p);
      for (const j of undersea.jellyfish) {
        if (j.caught) continue;
        const s = getSpriteSize('jellyfish');
        const jb = { x: Math.round(j.x - s.w/2), y: Math.round(j.y - s.h/2), w: s.w, h: s.h };
        if (rectsOverlap(pb, jb)) {
          undersea.jellyCollected = Math.min(5, undersea.jellyCollected + 1);
          j.caught = true;
          SFX.pickup();
          break;
        }
      }
      if (rectsOverlap(pb, undersea.grillArea)) {
        if (undersea.jellyCollected < 5 || undersea.picklesCollected < 3) drawLowerHint('You need more jelly or pickles before you can make the burger.');
        else { undersea.bunsPattyCollected = true; undersea.burgerMade = true; SFX.success(); shake(4,12); }
        return;
      }
      if (undersea.burgerMade && rectsOverlap(pb, undersea.exitSub)) { initHouse3PostBurger(); state = "house3"; }
    }
    //#endregion

    //#region Level: Ship Build + Launch
    function lerp(a,b,t){ return a + (b - a) * t; }
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
    const SHOW_ASSEMBLY_PAD = false;
    const shipBuild = {
      player:{x:0,y:0,w:0,h:0},
      pad:{ x: WIDTH - 360, y: HEIGHT - 180, w: 180, h: 70 },
      parts:{
        fuselage:  { spr:'ship_part_fuselage',  have:false, offX:0, offY:0, scale:1.00, x:0,y:0,s:1, anim:false, t:0, fromX:0,fromY:0,fromS:0.7 },
        canopy:    { spr:'ship_part_canopy',    have:false, offX:0, offY:0, scale:1.00, x:0,y:0,s:1, anim:false, t:0, fromX:0,fromY:0,fromS:0.7 },
        wrapper:   { spr:'ship_part_wrapper',   have:false, offX:0, offY:0, scale:1.00, x:0,y:0,s:1, anim:false, t:0, fromX:0,fromY:0,fromS:0.7 },
        jellyFuel: { spr:'ship_part_jelly_fuel',have:false, offX:0, offY:0, scale:1.00, x:0,y:0,s:1, anim:false, t:0, fromX:0,fromY:0,fromS:0.7 }
      }
    };
    function recalcPartTargetsFromPad(){
      for (const p of Object.values(shipBuild.parts)){
        p.toX = shipBuild.pad.x + (p.offX || 0);
        p.toY = shipBuild.pad.y + (p.offY || 0);
      }
    }
    function initShipBuild(){
      const ps=getSpriteSize('player_side');
      shipBuild.player={x:WIDTH/2, y:HEIGHT-120, w:ps.w, h:ps.h};
      recalcPartTargetsFromPad();
      for (const p of Object.values(shipBuild.parts)){
        p.x = p.toX; p.y = p.toY; p.s = p.scale; p.anim = false; p.t = 0;
      }
    }
    function moveShipBuildPlayer(dx,dy){
      shipBuild.player.x=Math.max(20,Math.min(WIDTH-40,shipBuild.player.x+dx*TILE));
      shipBuild.player.y=Math.max(260,Math.min(HEIGHT-40,shipBuild.player.y+dy*TILE));
    }
    function updateShipBuild(){
      for (const p of Object.values(shipBuild.parts)){
        if (!p.anim) continue;
        p.t = Math.min(1, p.t + 0.08);
        const e = easeOutCubic(p.t);
        p.x = lerp(p.fromX, p.toX, e);
        p.y = lerp(p.fromY, p.toY, e);
        p.s = lerp(p.fromS, p.scale, e);
        if (p.t >= 1) p.anim = false;
      }
    }
    function allShipPartsHave(){
      const k = shipBuild.parts;
      return k.fuselage.have && k.canopy.have && k.wrapper.have && k.jellyFuel.have;
    }
    function drawShipBuild(){
      drawSprite('shipyard_ground',0,0,WIDTH,HEIGHT);
      drawSprite('shed',280,HEIGHT-220,80,60);
      drawSprite('tree',60,HEIGHT-300,60,100);
      drawSprite('lab',WIDTH-200,HEIGHT-240,80,80);
      drawSprite('trash_can',200,HEIGHT-200,24,40);
      drawSprite('canopy_room', WIDTH/2 - 60, HEIGHT-230, 60, 50);
      const ready = allShipPartsHave();
      if (!ready){
        for (const [key,p] of Object.entries(shipBuild.parts)){
          if (!p.have) continue;
          const base = getSpriteSize(p.spr);
          const w = Math.round(base.w * p.s), h = Math.round(base.h * p.s);
          drawSprite(p.spr, Math.round(p.x), Math.round(p.y), w, h);
        }
      } else {
        drawSprite('spaceship_blue', shipBuild.pad.x, shipBuild.pad.y, shipBuild.pad.w, shipBuild.pad.h);
      }
      drawSpriteAuto('player_side', shipBuild.player.x, shipBuild.player.y, {anchor:'bottom'});
      debugDrawBox(getPlayerBoxBottom(shipBuild.player), shipBuild.player.x, shipBuild.player.y);
      const {fuselage, jellyFuel, wrapper, canopy} = shipBuild.parts;
      drawHUDBar(); ctx.fillStyle='#fff'; ctx.font='14px sans-serif';
      ctx.fillText('Shipyard: Collect parts and assemble the blue spaceship. E to interact. (F2 shows hitboxes)', 10, 20);
      ctx.fillText('Fuselage: ' + (fuselage.have?'✓':' ') + '  Jelly Fuel: ' + (jellyFuel.have?'✓':' ') + '  Wrapper: ' + (wrapper.have?'✓':' ') + '  Canopy: ' + (canopy.have?'✓':' '), 10, 38);
    }
    function shipBuildInteract(key){
      if(!(key===' '||key==='Enter'||key.toLowerCase()==='e')) return;
      const pb=getPlayerBoxBottom(shipBuild.player);
      const zones = {
        fuselage : { box:{x:60,y:HEIGHT-300,w:60,h:100} },
        jellyFuel: { box:{x:WIDTH-200,y:HEIGHT-240,w:80,h:80} },
        wrapper  : { box:{x:200,y:HEIGHT-200,w:24,h:40} },
        canopy   : { box:{x:WIDTH/2-60,y:HEIGHT-230,w:60,h:50} }
      };
      for (const [name, data] of Object.entries(zones)){
        const part = shipBuild.parts[name];
        if (!part.have && rectsOverlap(pb, data.box)){
          part.have = true;
          recalcPartTargetsFromPad();
          part.anim = true; part.t = 0;
          part.fromX = pb.x; part.fromY = pb.y; part.fromS = 0.7;
          part.x = part.fromX; part.y = part.fromY; part.s = part.fromS;
          SFX.success();
          break;
        }
      }
      if (allShipPartsHave()){
        const shipBox={x:shipBuild.pad.x,y:shipBuild.pad.y,w:shipBuild.pad.w,h:shipBuild.pad.h};
        if(rectsOverlap(pb,shipBox)){ initShipLaunch(); state='ship_launch'; }
      }
    }
    const shipLaunch={t:0};
    function initShipLaunch(){ shipLaunch.t=0; }
    function updateShipLaunch(){ shipLaunch.t+=1; if(shipLaunch.t>180){ initMoonBoss(); state='moon_boss'; } }
    function drawShipLaunch(){
      const t=shipLaunch.t, offY=-t*1.2;
      drawSprite('starfield',0,0,WIDTH,HEIGHT);
      const baseY=HEIGHT-260+offY;
      drawSprite('spaceship_blue', WIDTH/2-80, baseY, 160, 50);
      drawSprite('thruster_flame', WIDTH/2-60, baseY+50, 20, 10);
      drawSprite('thruster_flame', WIDTH/2+20, baseY+50, 20, 10);
      drawHUDBar(); ctx.fillStyle='#fff'; ctx.font='14px sans-serif';
      ctx.fillText('SPACESHIP TIME! Garfield looks out the window as you blast off toward the moon.', 10, 22);
      drawBottomBar(); ctx.fillStyle='#fff'; ctx.fillText('Next stop: the moon... and the Wish Star.', 10, HEIGHT-18);
    }
    //#endregion

    //#region Level: Moon Boss + Wish Scene
    function drawToHeight(name, centerX, feetY, targetH){
      const img = IMAGES[name]; if (!img) return;
      const aspect = (img.naturalWidth / img.naturalHeight) || 1;
      const w = Math.round(targetH * aspect), h = Math.round(targetH);
      ctx.drawImage(img, Math.round(centerX - w/2), Math.round(feetY - h), w, h);
    }
    const moon={ substate:'stage1', lastSubstate:'stage1',
      player1:{x:WIDTH/2-12,y:HEIGHT-40,w:24,h:24,speed:3,hp:3},
      dragon1:{x:WIDTH/2-80,y:40,w:160,h:60,hp:12,maxHp:12,phase:'rain',phaseTimer:0,hitFlash:0},
      bullets:[], shots:[], warnings:[], shotCooldown:0, stage1Done:false,
      player2:{x:80,y:HEIGHT-64,w:24,h:32,vx:0,vy:0,speed:2.5,onGround:false,hp:3},
      dragon2:{x:WIDTH-160,y:HEIGHT-104,w:120,h:64,hp:5,maxHp:5,phase:'approach',phaseTimer:0,hitFlash:0,dir:-1},
      punchCooldown:0
    };
    function initMoonBoss(){ moon.substate='stage1'; moon.lastSubstate='stage1';
      moon.player1={x:WIDTH/2-12,y:HEIGHT-40,w:24,h:24,speed:3,hp:3};
      moon.dragon1={x:WIDTH/2-80,y:40,w:160,h:60,hp:12,maxHp:12,phase:'rain',phaseTimer:0,hitFlash:0};
      moon.bullets.length=0; moon.shots.length=0; moon.warnings.length=0; moon.shotCooldown=0; moon.stage1Done=false;
      moon.player2={x:80,y:HEIGHT-64,w:24,h:32,vx:0,vy:0,speed:2.5,onGround:false,hp:3};
      moon.dragon2={x:WIDTH-160,y:HEIGHT-104,w:120,h:64,hp:5,maxHp:5,phase:'approach',phaseTimer:0,hitFlash:0,dir:-1};
      moon.punchCooldown=0;
    }
    function startMoonStage2(){ moon.substate='stage2'; moon.lastSubstate='stage2';
      moon.player2={x:80,y:HEIGHT-64,w:24,h:32,vx:0,vy:0,speed:2.5,onGround:false,hp:3};
      moon.dragon2={x:WIDTH-160,y:HEIGHT-104,w:120,h:64,hp:5,maxHp:5,phase:'approach',phaseTimer:0,hitFlash:0,dir:-1};
      moon.punchCooldown=0;
    }
    function spawnWarning(x,y,r,delay=40,kind='drop',meta=null){ moon.warnings.push({x,y,r,ttl:delay,kind,meta}); }
    function spawnFire(x,y,vx,vy,r=8){ moon.shots.push({x,y,vx,vy,r}); SFX.fire(); }
    function updateMoonBoss(){ if(moon.substate==='stage1') updateMoonStage1(); else if(moon.substate==='stage2') updateMoonStage2(); }
    function drawMoonBoss(){ if(moon.substate==='stage1') drawMoonStage1(); else if(moon.substate==='stage2') drawMoonStage2(); else if(moon.substate==='lose'){ if(moon.lastSubstate==='stage1') drawMoonStage1(); else drawMoonStage2(); drawCenteredBanner('You were defeated. Press R to retry.'); } }
    function moonBossInteract(key){ if(key==='r'||key==='R') initMoonBoss(); }
    function updateMoonStage1(){
      let dx=0; if(keys['ArrowLeft']||keys['a']) dx-=1; if(keys['ArrowRight']||keys['d']) dx+=1;
      moon.player1.x += dx*moon.player1.speed;
      if(moon.player1.x<20) moon.player1.x=20;
      if(moon.player1.x+moon.player1.w>WIDTH-20) moon.player1.x=WIDTH-20-moon.player1.w;
      if(moon.shotCooldown>0) moon.shotCooldown--;
      if((keys['k']||keys['K']||keys[' ']||keys['e']||keys['E']) && moon.shotCooldown===0 && !moon.stage1Done){
        moon.bullets.push({x:moon.player1.x+moon.player1.w/2-3,y:moon.player1.y,w:6,h:10,vy:-4}); moon.shotCooldown=25; SFX.shoot();
      }
      for(let i=moon.bullets.length-1;i>=0;i--){ moon.bullets[i].y+=moon.bullets[i].vy; if(moon.bullets[i].y + moon.bullets[i].h < 0) moon.bullets.splice(i,1); }
      for(let i=moon.warnings.length-1;i>=0;i--){
        const w = moon.warnings[i]; w.ttl--;
        if(w.ttl<=0){
          if(w.kind==='drop'){ spawnFire(w.x,w.y,0,2.6,w.r); }
          else if(w.kind==='burst'){
            const n=(w.meta&&w.meta.n)||8, speed=(w.meta&&w.meta.speed)||2.2, cx=w.x, cy=w.y;
            for(let k=0;k<n;k++){ const ang=k*(Math.PI*2/n); spawnFire(cx,cy,Math.cos(ang)*speed,Math.sin(ang)*speed,7); }
          }
          moon.warnings.splice(i,1);
        }
      }
      moon.dragon1.phaseTimer++;
      if(!moon.stage1Done){
        if(moon.dragon1.phase==='rain'){
          if(moon.dragon1.phaseTimer%60===0){
            for(let i=0;i<6;i++){
              const x = 60 + i*((WIDTH-120)/5);
              const y = moon.dragon1.y + moon.dragon1.h + 6;
              spawnWarning(x,y,10,28,'drop');
            }
          }
          if(moon.dragon1.phaseTimer>180){ moon.dragon1.phase='burst'; moon.dragon1.phaseTimer=0; }
        } else if(moon.dragon1.phase==='burst'){
          if(moon.dragon1.phaseTimer===1){
            const cx = moon.dragon1.x + moon.dragon1.w/2, cy = moon.dragon1.y + moon.dragon1.h - 6;
            spawnWarning(cx,cy,12,30,'burst',{n:10,speed:2.4});
          }
          if(moon.dragon1.phaseTimer>90){ moon.dragon1.phase='rain'; moon.dragon1.phaseTimer=0; }
        }
      }
      const dBox={x:moon.dragon1.x,y:moon.dragon1.y,w:moon.dragon1.w,h:moon.dragon1.h};
      for(let i=moon.bullets.length-1;i>=0;i--){
        if(!moon.stage1Done && rectsOverlap(moon.bullets[i], dBox)){
          moon.dragon1.hp=Math.max(0,moon.dragon1.hp-1); moon.dragon1.hitFlash=6; moon.bullets.splice(i,1);
          SFX.hit(); shake(6,12);
        }
      }
      for(let i=moon.shots.length-1;i>=0;i--){
        moon.shots[i].x+=moon.shots[i].vx; moon.shots[i].y+=moon.shots[i].vy;
        if(moon.shots[i].y - moon.shots[i].r > HEIGHT) moon.shots.splice(i,1);
      }
      const pBox={x:moon.player1.x,y:moon.player1.y,w:moon.player1.w,h:moon.player1.h};
      for(let i=moon.shots.length-1;i>=0;i--){
        const s=moon.shots[i], sb={x:s.x - s.r,y:s.y - s.r,w:s.r*2,h:s.r*2};
        if(!moon.stage1Done && rectsOverlap(sb,pBox)){
          moon.player1.hp=Math.max(0,moon.player1.hp-1); moon.shots.splice(i,1); SFX.hurt(); shake(5,8);
        }
      }
      if(!moon.stage1Done && moon.dragon1.hp<=0){ moon.stage1Done=true; startMoonStage2(); }
      if(moon.player1.hp<=0 && moon.substate==='stage1'){ moon.lastSubstate='stage1'; moon.substate='lose'; }
    }
    function drawMoonStage1(){
      drawSprite('starfield_bg',0,0,WIDTH,HEIGHT); drawSprite('moon_disc',50,50,60,60);
      drawSprite('dragon_stage1', moon.dragon1.x, moon.dragon1.y, moon.dragon1.w, moon.dragon1.h);
      drawSprite('chest_gem', moon.dragon1.x+30, moon.dragon1.y+20, 20, 20);
      for(const w of moon.warnings) drawSprite('warning_circle', w.x - w.r, w.y - w.r, w.r*2, w.r*2);
      for(const s of moon.shots) drawSprite('fireball', s.x - s.r, s.y - s.r, s.r*2, s.r*2);
      drawSprite('player_side', moon.player1.x, moon.player1.y, moon.player1.w, moon.player1.h);
      for(const b of moon.bullets) drawSprite('heart_bullet', b.x, b.y, b.w, b.h);
      drawHUDBar(); ctx.fillStyle='#fff'; ctx.font='14px sans-serif';
      ctx.fillText('Stage 1: Move A/D or arrows | Shoot K or Space or E | Avoid fireballs.',10,20);
      ctx.fillText('HP: ' + moon.player1.hp, 10, 36);
      ctx.fillText('Dragon (Stage 1)', WIDTH-200,20); drawHPBar(WIDTH-200,26,140,moon.dragon1.hp,moon.dragon1.maxHp);
    }
    function updateMoonStage2(){
      const p=moon.player2, d=moon.dragon2;
      p.vx=0; if(keys['ArrowLeft']||keys['a']) p.vx=-p.speed; if(keys['ArrowRight']||keys['d']) p.vx=p.speed;
      p.x+=p.vx; if(p.x<20)p.x=20; if(p.x+p.w>WIDTH-20)p.x=WIDTH-20-p.w;
      p.vy+=0.3; p.y+=p.vy; if(p.y+p.h>HEIGHT-40){p.y=HEIGHT-40-p.h;p.vy=0;p.onGround=true;} else p.onGround=false;
      if((keys['w']||keys['ArrowUp']||keys[' '])&&p.onGround){ p.vy=-5; p.onGround=false; }
      if(moon.punchCooldown>0) moon.punchCooldown--;
      if((keys['j']||keys['J']||keys['e']||keys['E']||keys[' ']) && moon.punchCooldown === 0){
        moon.punchCooldown=20; const punchBox={x:p.x+p.w,y:p.y,w:20,h:p.h}, dBox={x:d.x,y:d.y,w:d.w,h:d.h};
        if(rectsOverlap(punchBox,dBox)){ d.hp=Math.max(0,d.hp-1); d.hitFlash=6; SFX.punch(); shake(6,12); }
      }
      if(d.hitFlash>0) d.hitFlash--;
      d.phaseTimer++;
      const pBox={x:p.x,y:p.y,w:p.w,h:p.h}, dist=d.x - (p.x + p.w);
      if(d.hp>0){
        if(d.phase==='approach'){ if(dist>60)d.x-=1.0; if(d.phaseTimer>90||dist<=60){d.phase='swipe'; d.phaseTimer=0; SFX.swipe(); } }
        else if(d.phase==='swipe'){
          if(d.phaseTimer===40){
            const swipeBox={x:d.x-40,y:d.y,w:40,h:d.h};
            if(rectsOverlap(pBox,swipeBox)) { p.hp=Math.max(0,p.hp-1); SFX.hurt(); shake(5,10); }
          }
          if(d.phaseTimer>80){ d.phase='pounce'; d.phaseTimer=0; }
        }
        else if(d.phase==='pounce'){
          const dir = (p.x + p.w/2) < (d.x + d.w/2) ? -1 : 1;
          d.x += 2.2 * dir;
          const dBox2={x:d.x,y:d.y,w:d.w,h:d.h};
          if(rectsOverlap(pBox,dBox2)){ p.hp=Math.max(0,p.hp-1); SFX.hurt(); shake(6,10); d.phase='approach'; d.phaseTimer=0; }
          if(d.phaseTimer>50){ d.phase='approach'; d.phaseTimer=0; }
        }
      }
      if(d.hp<=0 && state==='moon_boss'){ initWishScene(); state='wish_scene'; return; }
      if(p.hp<=0 && state==='moon_boss'){ moon.lastSubstate='stage2'; moon.substate='lose'; }
    }
    function drawMoonStage2(){
      drawSprite('starfield_bg',0,0,WIDTH,HEIGHT); drawSprite('lunar_ground',0,HEIGHT-40,WIDTH,40); drawSprite('spire', WIDTH-300, HEIGHT-180, 60, 140);
      drawSprite('player_side', moon.player2.x, moon.player2.y, moon.player2.w, moon.player2.h);
      drawSprite('dragon_stage2', moon.dragon2.x, moon.dragon2.y, moon.dragon2.w, moon.dragon2.h);
      if(moon.dragon2.phase==='swipe' && moon.dragon2.phaseTimer>=10 && moon.dragon2.phaseTimer<40){
        drawSprite('swipe_arc', moon.dragon2.x - 42, moon.dragon2.y, 48, moon.dragon2.h);
      }
      drawHUDBar(); ctx.fillStyle='#fff'; ctx.font='14px sans-serif';
      ctx.fillText('Stage 2: Move A/D or arrows | Jump W/Up/Space | Punch J or E or Space.',10,20);
      ctx.fillText('HP: ' + moon.player2.hp, 10, 36);
      ctx.fillText('Dragon (Stage 2)', WIDTH-200,20); drawHPBar(WIDTH-200,26,140,moon.dragon2.hp,moon.dragon2.maxHp);
    }

    function initWishScene(){
      house2.phase='post_burger';
      house2.feedingStep=0;
      BGM.playWish(800);
    }
    function drawWishScene(){
      drawSprite('wish_room_bg',0,0,WIDTH,HEIGHT);
      const k = getSpriteSize('garfield_kitten');
      const kittenH = k.h;
      const actorH = Math.round(kittenH * 2);
      const feetY = HEIGHT - 128;
      const leftX = WIDTH/2 - 40;
      const rightX = WIDTH/2 + 40;
      if (house2.feedingStep <= 2){
        drawSprite('garfield_kitten', Math.round(leftX - k.w/2), Math.round(feetY - k.h), k.w, k.h);
      } else {
        drawToHeight('garfield_prince', leftX, feetY, actorH);
      }
      drawToHeight('player_topdown', rightX, feetY, actorH);
      drawSprite('wish_star', WIDTH/2 - 11, HEIGHT - 260, 24, 24);
      drawSprite('floating_heart', WIDTH/2 - 45, HEIGHT - 250, 10, 10);
      drawSprite('floating_heart', WIDTH/2 + 35, HEIGHT - 250, 10, 10);
      let text='';
      if(house2.feedingStep===0) text='A soft light fills the room. Garfield looks at you with bright eyes.';
      else if(house2.feedingStep===1) text='The Wish Star glimmers overhead, drawn by the collar\'s glow.';
      else if(house2.feedingStep===2) text='Garfield purrs. The star descends, and the collar hums.';
      else if(house2.feedingStep===3) text='With a shimmer, Garfield transforms into a prince.';
      else if(house2.feedingStep===4) text='This Wish Star could grant anything in the world.';
      else if(house2.feedingStep===5) text='But my only wish... has always been you.';
      else text='Sephera, be my forever valentine.\n\nWill you keep building in this world with me?';
      drawDialogueBox(text);
    }
    //#endregion

    //#region Input + main loop
    let jungleJumpHeld = false;
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      const isJumpKey = (ek =>
        ek.code === 'Space' || ek.code === 'KeyW' ||
        ek.key === ' ' || ek.key === 'Space' ||
        ek.key === 'ArrowUp' || ek.key === 'Up' ||
        (ek.key && ek.key.toLowerCase && ek.key.toLowerCase() === 'w')
      )(e);
      const isInteractKey = (ek =>
        ek.key === ' ' || ek.key === 'Enter' ||
        (ek.key && ek.key.toLowerCase && ek.key.toLowerCase() === 'e')
      )(e);

      // Input test gate
      if (state === 'input_test') {
        if (isInteractKey) inputTestInteract(e.key);
        return;
      }

      if (state === "lily") {
        if (isInteractKey) { lilyInteract(); return; }
        let dx = 0, dy = 0;
        if (e.key === 'ArrowLeft' || e.key === 'a') dx = -1;
        else if (e.key === 'ArrowRight' || e.key === 'd') dx = 1;
        else if (e.key === 'ArrowUp' || e.key === 'w') dy = -1;
        else if (e.key === 'ArrowDown' || e.key === 's') dy = 1;
        if (dx !== 0 || dy !== 0) {
          const nx = lily.player.x + dx, ny = lily.player.y + dy;
          const tileHere = lily.map[ny]?.[nx];
          const baseHere = lily.base[ny]?.[nx];
          if (lilyInsideBounds(nx, ny) && lilyIsWalkable(tileHere === TILE_GRASS ? baseHere : tileHere)) {
            lily.player.x = nx; lily.player.y = ny;
          }
        }
      } else if (state === "jungle") {
        if (isInteractKey) jungleInteract();
        if (isJumpKey && !jungleJumpHeld) {
          jungle.player.vy = -jungle.jumpStrength;
          jungle.player.onGround = false;
          jungleJumpHeld = true;
          SFX.jump();
        }
      } else if (state === "house2") {
        if (e.key === 'ArrowLeft' || e.key === 'a') moveHouse2Player(-1, 0);
        else if (e.key === 'ArrowRight' || e.key === 'd') moveHouse2Player(1, 0);
        else if (e.key === 'ArrowUp' || e.key === 'w') moveHouse2Player(0, -1);
        else if (e.key === 'ArrowDown' || e.key === 's') moveHouse2Player(0, 1);
        house2Interact(e.key);
      } else if (state === "hub2") {
        if (e.key === 'ArrowLeft' || e.key === 'a') moveHub2Player(-1, 0);
        else if (e.key === 'ArrowRight' || e.key === 'd') moveHub2Player(1, 0);
        else if (e.key === 'ArrowUp' || e.key === 'w') moveHub2Player(0, -1);
        else if (e.key === 'ArrowDown' || e.key === 's') moveHub2Player(0, 1);
        if (isInteractKey) hub2Interact(e.key);
      } else if (state === "taco") {
        if (isInteractKey) tacoInteract(e.key);
      } else if (state === "sushi") {
        sushiInteract(e.key);
      } else if (state === "dessert") {
        dessertInteract(e.key);
      } else if (state === "house3") {
        if (house3.phase !== "post_burger") {
          if (e.key === 'ArrowLeft' || e.key === 'a') moveHouse3Player(-1, 0);
          else if (e.key === 'ArrowRight' || e.key === 'd') moveHouse3Player(1, 0);
          else if (e.key === 'ArrowUp' || e.key === 'w') moveHouse3Player(0, -1);
          else if (e.key === 'ArrowDown' || e.key === 's') moveHouse3Player(0, 1);
          if (isInteractKey) house3Interact(e.key);
        } else {
          if (isInteractKey) { house2.feedingStep += 1; if (house2.feedingStep > 5) { initShipBuild(); state = "ship_build"; } }
        }
      } else if (state === "undersea") {
        if (isInteractKey) underseaInteract(e.key);
      } else if (state === "ship_build") {
        if (e.key === 'ArrowLeft' || e.key === 'a') moveShipBuildPlayer(-1, 0);
        else if (e.key === 'ArrowRight' || e.key === 'd') moveShipBuildPlayer(1, 0);
        else if (e.key === 'ArrowUp' || e.key === 'w') moveShipBuildPlayer(0, -1);
        else if (e.key === 'ArrowDown' || e.key === 's') moveShipBuildPlayer(0, 1);
        if (isInteractKey) shipBuildInteract(e.key);
      } else if (state === "moon_boss") {
        moonBossInteract(e.key);
      } else if (state === "wish_scene") {
        if (isInteractKey) house2.feedingStep += 1;
      }
    });
    window.addEventListener('keyup', e => {
      keys[e.key] = false;
      if (
        e.code === 'Space' || e.code === 'KeyW' ||
        e.key === ' ' || e.key === 'Space' ||
        e.key === 'ArrowUp' || e.key === 'Up' ||
        (e.key && e.key.toLowerCase && e.key.toLowerCase() === 'w')
      ) {
        jungleJumpHeld = false;
      }
    });

    // Mobile touch controls: map overlay buttons to key events
    function press(key) {
      if (state === 'input_test') inputTest.touchSeen = true;
      window.dispatchEvent(new KeyboardEvent('keydown', { key }));
    }
    function release(key) { window.dispatchEvent(new KeyboardEvent('keyup', { key })); }
    const keyMap = { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp', e: 'e' };
    document.querySelectorAll('button.ctrl').forEach(btn => {
      const mapped = keyMap[btn.dataset.k];
      btn.addEventListener('touchstart', e => { e.preventDefault(); press(mapped); });
      btn.addEventListener('touchend',   e => { e.preventDefault(); release(mapped); });
      btn.addEventListener('touchcancel',e => { e.preventDefault(); release(mapped); });
      btn.addEventListener('mousedown', e => { e.preventDefault(); press(mapped); });
      btn.addEventListener('mouseup',   e => { e.preventDefault(); release(mapped); });
      btn.addEventListener('mouseleave',e => { e.preventDefault(); release(mapped); });
    });

    // Xbox/standard Gamepad → Keyboard bridge
    const GP_CFG = { deadzone: 0.25, repeatDelay: 260, repeatRate: 120 };
    const gpState = {
      have: false,
      prevButtons: [],
      axisHeld: { ArrowLeft:false, ArrowRight:false, ArrowUp:false, ArrowDown:false },
      repeatNext: { ArrowLeft:0, ArrowRight:0, ArrowUp:0, ArrowDown:0 }
    };
    function kDown(k){ window.dispatchEvent(new KeyboardEvent('keydown',{ key:k })); }
    function kUp(k){ window.dispatchEvent(new KeyboardEvent('keyup',{ key:k })); }
    function dz(v){ const a = Math.abs(v||0); return a < GP_CFG.deadzone ? 0 : (v > 0 ? (a - GP_CFG.deadzone)/(1 - GP_CFG.deadzone) : -(a - GP_CFG.deadzone)/(1 - GP_CFG.deadzone)); }
    function setArrow(arrow, isDown, now){
      const held = gpState.axisHeld[arrow];
      if (isDown && !held){
        gpState.axisHeld[arrow] = true;
        kDown(arrow);
        gpState.repeatNext[arrow] = now + GP_CFG.repeatDelay;
      } else if (!isDown && held){
        gpState.axisHeld[arrow] = false;
        kUp(arrow);
      }
    }
    function maybeRepeatArrows(now){
      for (const arrow of ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown']){
        if (!gpState.axisHeld[arrow]) continue;
        if (now >= gpState.repeatNext[arrow]){
          kUp(arrow);
          kDown(arrow);
          gpState.repeatNext[arrow] = now + GP_CFG.repeatRate;
        }
      }
    }
    function handleButtons(gp){
      const map = [
        { idx: 0, key: ' ' },       // A → Space
        { idx: 1, key: 'e' },       // B → E
        { idx: 5, key: 'j' },       // RB → J (punch)
        { idx: 9, key: 'Enter' }    // Start → Enter
      ];
      const dpad = [
        { idx: 14, key: 'ArrowLeft' },
        { idx: 15, key: 'ArrowRight' },
        { idx: 12, key: 'ArrowUp' },
        { idx: 13, key: 'ArrowDown' }
      ];
      for (const {idx, key} of [...map, ...dpad]){
        const pressed = !!(gp.buttons[idx] && gp.buttons[idx].pressed);
        const prev = gpState.prevButtons[idx] || false;
        if (pressed && !prev) {
          if (state === 'input_test') inputTest.gamepadSeen = true;
          kDown(key);
        } else if (!pressed && prev) {
          kUp(key);
        }
        gpState.prevButtons[idx] = pressed;
      }
    }
    function handleAxes(gp, now){
      const axX = dz(gp.axes[0]);
      const axY = dz(gp.axes[1]);
      const left  = axX < -0.5;
      const right = axX >  0.5;
      const up    = axY < -0.5;
      const down  = axY >  0.5;
      setArrow('ArrowLeft', left, now);
      setArrow('ArrowRight', right, now);
      setArrow('ArrowUp', up, now);
      setArrow('ArrowDown', down, now);
      maybeRepeatArrows(now);
    }
    function pollGamepad(){
      const list = navigator.getGamepads ? navigator.getGamepads() : [];
      const gp = list && list[0];
      const now = performance.now();
      if (gp && gp.connected){
        if (!gpState.have) gpState.have = true;
        handleButtons(gp);
        handleAxes(gp, now);
      } else {
        if (gpState.have){
          for (const idx in gpState.prevButtons){
            if (gpState.prevButtons[idx]) gpState.prevButtons[idx] = false;
          }
          for (const a of Object.keys(gpState.axisHeld)){
            if (gpState.axisHeld[a]) { gpState.axisHeld[a] = false; kUp(a); }
          }
          gpState.have = false;
        }
      }
      requestAnimationFrame(pollGamepad);
    }
    window.addEventListener('gamepadconnected', () => { gpState.have = true; });
    window.addEventListener('gamepaddisconnected', () => { gpState.have = false; });
    requestAnimationFrame(pollGamepad);

    function update(){
      if(state==='input_test') updateInputTest();
      else if(state==='lily') updateLily();
      else if(state==='jungle') updateJungle();
      else if(state==='house2') {/* dialog-driven */}
      else if(state==='undersea') updateUndersea();
      else if(state==='ship_build') updateShipBuild();
      else if(state==='ship_launch') updateShipLaunch();
      else if(state==='moon_boss') updateMoonBoss();
    }
    function draw(){
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      ctx.save(); applyShake();
      if(state==='input_test') drawInputTest();
      else if(state==='lily') drawLily();
      else if(state==='jungle') drawJungle();
      else if(state==='house2') drawHouse2();
      else if(state==='hub2') drawHub2();
      else if(state==='taco') drawTaco();
      else if(state==='sushi') drawSushi();
      else if(state==='dessert') drawDessert();
      else if(state==='house3'){ if(house3.phase!=='post_burger') drawHouse3(); else drawHouse3PostBurger(); }
      else if(state==='undersea') drawUndersea();
      else if(state==='ship_build') drawShipBuild();
      else if(state==='ship_launch') drawShipLaunch();
      else if(state==='moon_boss') drawMoonBoss();
      else if(state==='wish_scene') drawWishScene();
      else if(state==='loading'){
        ctx.fillStyle = '#111827';
        ctx.fillRect(0,0,WIDTH,HEIGHT);
        drawHUDBar();
        ctx.fillStyle = '#fff';
        ctx.font = '14px sans-serif';
        ctx.fillText('Loading…', 10, 22);
      }
      ctx.restore();
    }
    function loop(){ update(); draw(); requestAnimationFrame(loop); }
    initInputTest();
    requestAnimationFrame(loop);
    //#endregion
  </script>
</body>
</html>